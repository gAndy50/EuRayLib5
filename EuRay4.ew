------------------------------------------------
--EuRayLib4									  --
--Written by Andy P.						  --
--Raylib Wrapper for Euphoria of Raylib Ver 4 --
--Icy Viking Games							  --
--Eu Ver: 4.1.0 Beta 2					      --
--Raylib Ver: 4.0							  --
------------------------------------------------
without warning

include std/dll.e
include std/machine.e
include std/os.e

public atom ray = 0

ifdef WINDOWS then
	ray = open_dll("raylib.dll")
	elsifdef LINUX or FREEBSD then
	ray = open_dll("raylib.so")
end ifdef

include flags.e

public constant RAYLIB_VERSION = 4.0

public constant PI = 3.14159265358979323846
public constant DEG2RAD = PI / 180.0
public constant RAD2DEG = 180.0 / PI

--Window Functions
public constant xInitWindow = define_c_proc(ray,"+InitWindow",{C_INT,C_INT,C_POINTER}),
				xWindowShouldClose = define_c_func(ray,"+WindowShouldClose",{},C_BOOL),
				xCloseWindow = define_c_proc(ray,"+CloseWindow",{}),
				xIsWindowReady = define_c_func(ray,"+IsWindowReady",{},C_BOOL),
				xIsWindowFullscreen = define_c_func(ray,"+IsWindowFullscreen",{},C_BOOL),
				xIsWindowHidden = define_c_func(ray,"+IsWindowHidden",{},C_BOOL),
				xIsWindowMinimized = define_c_func(ray,"+IsWindowMinimized",{},C_BOOL),
				xIsWindowMaximized = define_c_func(ray,"+IsWindowMaximized",{},C_BOOL),
				xIsWindowFocused = define_c_func(ray,"+IsWindowFocused",{},C_BOOL),
				xIsWindowResized = define_c_func(ray,"+IsWindowResized",{},C_BOOL),
				xIsWindowState = define_c_func(ray,"+IsWindowState",{C_UINT},C_BOOL),
				xSetWindowState = define_c_proc(ray,"+SetWindowState",{C_UINT}),
				xClearWindowState = define_c_proc(ray,"+ClearWindowState",{C_UINT}),
				xToggleFullscreen = define_c_proc(ray,"+ToggleFullscreen",{}),
				xMaximizeWindow = define_c_proc(ray,"+MaximizeWindow",{}),
				xMinimizeWindow = define_c_proc(ray,"+MinimizeWindow",{}),
				xRestoreWindow = define_c_proc(ray,"+RestoreWindow",{}),
				xSetWindowIcon = define_c_proc(ray,"+SetWindowIcon",{C_POINTER}),
				xSetWindowTitle = define_c_proc(ray,"+SetWindowTitle",{C_POINTER}),
				xSetWindowPosition = define_c_proc(ray,"+SetWindowPosition",{C_INT,C_INT}),
				xSetWindowMonitor = define_c_proc(ray,"+SetWindowMonitor",{C_INT}),
				xSetWindowMinSize = define_c_proc(ray,"+SetWindowMinSize",{C_INT,C_INT}),
				xSetWindowSize = define_c_proc(ray,"+SetWindowSize",{C_INT,C_INT}),
				xGetWindowHandle = define_c_func(ray,"+GetWindowHandle",{},C_POINTER),
				xGetScreenWidth = define_c_func(ray,"+GetScreenWidth",{},C_INT),
				xGetScreenHeight = define_c_func(ray,"+GetScreenHeight",{},C_INT),
				xGetMonitorCount = define_c_func(ray,"+GetMonitorCount",{},C_INT),
				xGetCurrentMonitor = define_c_func(ray,"+GetCurrentMonitor",{},C_INT),
				xGetMonitorPosition = define_c_func(ray,"+GetMonitorPosition",{C_INT},C_FLOAT),
				xGetMonitorWidth = define_c_func(ray,"+GetMonitorWidth",{C_INT},C_INT),
				xGetMonitorHeight = define_c_func(ray,"+GetMonitorHeight",{C_INT},C_INT),
				xGetMonitorPhysicalWidth = define_c_func(ray,"+GetMonitorPhysicalWidth",{C_INT},C_INT),
				xGetMonitorPhysicalHeight = define_c_func(ray,"+GetMonitorPhysicalHeight",{C_INT},C_INT),
				xGetMonitorRefreshRate = define_c_func(ray,"+GetMonitorRefreshRate",{C_INT},C_INT),
				xGetWindowPosition = define_c_func(ray,"+GetWindowPosition",{},C_FLOAT),
				xGetWindowScaleDPI = define_c_func(ray,"+GetWindowScaleDPI",{},C_FLOAT),
				xGetMonitorName = define_c_func(ray,"+GetMonitorName",{C_INT},C_POINTER),
				xSetClipboardText = define_c_proc(ray,"+SetClipboardText",{C_POINTER}),
				xGetClipboardText = define_c_func(ray,"+GetClipboardtext",{},C_POINTER)
				
public procedure InitWindow(atom w,atom h,sequence title)

 atom str = allocate_string(title,1)
 
 c_proc(xInitWindow,{w,h,str})
	
end procedure

public function WindowShouldClose()

 return c_func(xWindowShouldClose,{})
	
end function

public procedure CloseWindow()

 c_proc(xCloseWindow,{})
	
end procedure

public function IsWindowReady()

 return c_func(xIsWindowReady,{})
	
end function

public function IsWindowFullscreen()

 return c_func(xIsWindowFullscreen,{})
	
end function

public function IsWindowHidden()

 return c_func(xIsWindowHidden,{})
	
end function

public function IsWindowMinimized()

 return c_func(xIsWindowMinimized,{})
	
end function

public function IsWindowMaximized()

 return c_func(xIsWindowMaximized,{})
	
end function

public function IsWindowFocused()

 return c_func(xIsWindowFocused,{})
	
end function

public function IsWindowResized()

 return c_func(xIsWindowResized,{})
	
end function

public function IsWindowState(atom flag)

 return c_func(xIsWindowState,{flag})
	
end function

public procedure SetWindowState(atom flags)

 c_proc(xSetWindowState,{flags})
	
end procedure

public procedure ClearWindowState(atom flags)

 c_proc(xClearWindowState,{flags})
	
end procedure

public procedure ToggleFullscreen()

 c_proc(xToggleFullscreen,{})
	
end procedure

public procedure MaximizeWindow()

 c_proc(xMaximizeWindow,{})
	
end procedure

public procedure MinimizeWindow()

 c_proc(xMinimizeWindow,{})
	
end procedure

public procedure RestoreWindow()

 c_proc(xRestoreWindow,{})
	
end procedure

public procedure SetWindowIcon(atom image)

 c_proc(xSetWindowIcon,{image})
	
end procedure

public procedure SetWindowTitle(sequence title)

 atom str = allocate_string(title,1)
 
 c_proc(xSetWindowTitle,{str})
	
end procedure

public procedure SetWindowPosition(atom x,atom y)

 c_proc(xSetWindowPosition,{x,y})
	
end procedure

public procedure SetWindowMonitor(atom mon)

 c_proc(xSetWindowMonitor,{mon})
	
end procedure

public procedure SetWindowMinSize(atom w,atom h)

 c_proc(xSetWindowMinSize,{w,h})
	
end procedure

public procedure SetWindowSize(atom w,atom h)

 c_proc(xSetWindowSize,{w,h})
	
end procedure

public function GetWindowHandle()

 return c_func(xGetWindowHandle,{})
	
end function

public function GetScreenWidth()

 return c_func(xGetScreenWidth,{})
	
end function

public function GetScreenHeight()

 return c_func(xGetScreenHeight,{})
	
end function

public function GetMonitorCount()

 return c_func(xGetMonitorCount,{})
	
end function

public function GetCurrentMonitor()

 return c_func(xGetCurrentMonitor,{})
	
end function

public function GetMonitorPosition(atom mon)

 return c_func(xGetMonitorPosition,{mon})
	
end function

public function GetMonitorWidth(atom mon)

 return c_func(xGetMonitorWidth,{mon})
	
end function

public function GetMonitorHeight(atom mon)

 return c_func(xGetMonitorHeight,{mon})
	
end function

public function GetMonitorPhysicalWidth(atom mon)

 return c_func(xGetMonitorPhysicalWidth,{mon})
	
end function

public function GetMonitorPhysicalHeight(atom mon)

 return c_func(xGetMonitorPhysicalHeight,{mon})
	
end function

public function GetMonitorRefreshRate(atom mon)

 return c_func(xGetMonitorRefreshRate,{mon})
	
end function

public function GetWindowPosition()

 return c_func(xGetWindowPosition,{})
	
end function

public function GetWindowScaleDPI()

 return c_func(xGetWindowScaleDPI,{})
	
end function

public function GetMonitorName(atom mon)

 return c_func(xGetMonitorName,{mon})
	
end function

public procedure SetClipboardText(sequence text)

 atom str = allocate_string(text,1)
 
 c_proc(xSetClipboardText,{str})
	
end procedure

public function GetClipboardText()

 return c_func(xGetClipboardText,{})
	
end function

--Custom Frame Control Functions

public constant xSwapScreenBuffer = define_c_proc(ray,"+SwapScreenBuffer",{}),
				xPollInputEvents = define_c_proc(ray,"+PollInputEvents",{}),
				xWaitTime = define_c_proc(ray,"+WaitTime",{C_FLOAT})
				
public procedure SwapScreenBuffer()

 c_proc(xSwapScreenBuffer,{})
	
end procedure

public procedure PollInputEvents()

 c_proc(xPollInputEvents,{})
	
end procedure

public procedure WaitTime(atom ms)

 c_proc(xWaitTime,{ms})
	
end procedure

--Cursor Functions

public constant xShowCursor = define_c_proc(ray,"+ShowCursor",{}),
				xHideCursor = define_c_proc(ray,"+Hidecursor",{}),
				xIsCursorHidden = define_c_func(ray,"+IsCursorHidden",{},C_BOOL),
				xEnableCursor = define_c_proc(ray,"+EnableCursor",{}),
				xDisableCursor = define_c_proc(ray,"+DisableCursor",{}),
				xIsCursorOnScreen = define_c_func(ray,"+IsCursorOnScreen",{},C_BOOL)
				
public procedure ShowCursor()

 c_proc(xShowCursor,{})
	
end procedure

public procedure HideCursor()

 c_proc(xHideCursor,{})
	
end procedure

public function IsCursorHidden()

 return c_func(xIsCursorHidden,{})
	
end function

public procedure EnableCursor()

 c_proc(xEnableCursor,{})
	
end procedure

public procedure DisableCursor()

 c_proc(xDisableCursor,{})
	
end procedure

public function IsCursorOnScreen()

 return c_func(xIsCursorOnScreen,{})
	
end function

--Drawing Functions

public constant xClearBackground = define_c_proc(ray,"+ClearBackground",{C_UINT}),
				xBeginDrawing = define_c_proc(ray,"+BeginDrawing",{}),
				xEndDrawing = define_c_proc(ray,"+EndDrawing",{}),
				xBeginMode2D = define_c_proc(ray,"+BeginMode2D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT}),
				xEndMode2D = define_c_proc(ray,"+EndMode2D",{}),
				xBeginMode3D = define_c_proc(ray,"+BeginMode3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT}),
				xEndMode3D = define_c_proc(ray,"+EndMode3D",{}),
				xBeginTextureMode = define_c_proc(ray,"+BeginTextureMode",{C_INT,C_POINTER,C_POINTER}),
				xEndTextureMode = define_c_proc(ray,"+EndTextureMode",{}),
				xBeginShaderMode = define_c_proc(ray,"+BeginShaderMode",{C_INT,C_POINTER}),
				xEndShaderMode = define_c_proc(ray,"+EndShaderMode",{}),
				xBeginBlendMode = define_c_proc(ray,"+BeginBlendMode",{C_INT}),
				xEndBlendMode = define_c_proc(ray,"+EndBlendMode",{}),
				xBeginScissorMode = define_c_proc(ray,"+BeginScissorMode",{C_INT,C_INT,C_INT,C_INT}),
				xEndScissorMode = define_c_proc(ray,"+EndScissorMode",{}),
				xBeginVrStereoMode = define_c_proc(ray,"+BeginVrStereoMode",{C_POINTER}),
				xEndVrStereoMode = define_c_proc(ray,"+EndVrStereoMode",{})
				
public procedure ClearBackground(atom col)

 c_proc(xClearBackground,{col})
	
end procedure

public procedure BeginDrawing()

 c_proc(xBeginDrawing,{})
	
end procedure

public procedure EndDrawing()

 c_proc(xEndDrawing,{})
	
end procedure

public procedure BeginMode2D(atom offx,atom offy,atom tarx,atom tary,atom rot,atom zoom)

 c_proc(xBeginMode2D,{offx,offy,tarx,tary,rot,zoom})
	
end procedure

public procedure EndMode2D()

 c_proc(xEndMode2D,{})
	
end procedure

public procedure BeginMode3D(atom posx,atom posy,atom posz,atom tarx,atom tary,atom tarz,atom ux,atom uy,atom uz,atom fov,atom proj)

 c_proc(xBeginMode3D,{posx,posy,posz,tarx,tary,tarz,ux,uy,uz,fov,proj})
	
end procedure

public procedure EndMode3D()

 c_proc(xEndMode3D,{})
	
end procedure

public procedure BeginShaderMode(atom id,atom locs)

 c_proc(xBeginShaderMode,{id,locs})
	
end procedure

public procedure EndShaderMode()

 c_proc(xEndShaderMode,{})
	
end procedure

public procedure BeginBlendMode(atom mode)

 c_proc(xBeginBlendMode,{mode})
	
end procedure

public procedure EndBlendMode()

 c_proc(xEndBlendMode,{})
	
end procedure

public procedure BeginScissorMode(atom x,atom y,atom w,atom h)

 c_proc(xBeginScissorMode,{x,y,w,h})
	
end procedure

public procedure EndScissorMode()

 c_proc(xEndScissorMode,{})
	
end procedure

public procedure BeginVrStereoMode(atom config)

 c_proc(xBeginVrStereoMode,{config})
	
end procedure

public procedure EndVrStereoMode()

 c_proc(xEndVrStereoMode,{})
	
end procedure

public constant xLoadVrStereoConfig = define_c_func(ray,"+LoadVrStereoConfig",{C_POINTER},C_POINTER),
				xUnloadVrStereoConfig = define_c_proc(ray,"+UnloadVrStereoConfig",{C_POINTER})
				
public function LoadVrStereoConfig(atom dev)

 return c_func(xLoadVrStereoConfig,{dev})
	
end function

public procedure UnloadVrStereoConfig(atom con)

 c_proc(xUnloadVrStereoConfig,{con})
	
end procedure

--Shader Functions

public constant xLoadShader = define_c_func(ray,"+LoadShader",{C_POINTER,C_POINTER},C_POINTER),
				xLoadShaderFromMemory = define_c_func(ray,"+LoadShaderFromMemory",{C_POINTER,C_POINTER},C_POINTER),
				xGetShaderLocation = define_c_func(ray,"+GetShaderLocation",{C_INT,C_INT,C_POINTER},C_INT),
				xGetShaderLocationAttrib = define_c_func(ray,"+GetShaderLocationAttrib",{C_INT,C_INT,C_POINTER},C_INT),
				xSetShaderValue = define_c_proc(ray,"+SetShaderValue",{C_INT,C_INT,C_INT,C_POINTER,C_INT}),
				xSetShaderValueV = define_c_proc(ray,"+SetShaderValueV",{C_INT,C_INT,C_INT,C_POINTER,C_INT}),
				xSetShaderValueMatrix = define_c_proc(ray,"+SetShaderValueMatrix",{C_INT,C_INT,C_INT,C_FLOAT}),
				xSetShaderValueTexture = define_c_proc(ray,"+SetShaderValueTexture",{C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT}),
				xUnloadShader = define_c_proc(ray,"+UnloadShader",{C_INT,C_INT})
				
public function LoadShader(sequence file, sequence file2)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(file2,1)
 
 return c_func(xLoadShader,{str,str2})
	
end function
				
public function LoadShaderFromMemory(sequence vscode,sequence fscode)

 atom str = allocate_string(vscode,1)
 atom str2 = allocate_string(fscode,1)
 
 return c_func(xLoadShaderFromMemory,{str,str2})
	
end function

public function GetShaderLocation(atom id,atom locs,sequence name)

 atom str = allocate_string(name,1)
 
 return c_func(xGetShaderLocation,{id,locs,str})
	
end function

public function GetShaderLocationAttrib(atom id,atom locs,sequence name)

 atom str = allocate_string(name,1)
 
 return c_func(xGetShaderLocationAttrib,{id,locs,str})
	
end function

public procedure SetShaderValue(atom id,atom locs,atom val,atom uni)

 c_proc(xSetShaderValue,{id,locs,val,uni})
	
end procedure

public procedure SetShaderValueV(atom id,atom locs,atom indx,atom val,atom uni,atom count)

 c_proc(xSetShaderValueV,{id,locs,indx,val,uni,count})
	
end procedure

public procedure SetShaderValueMatrix(atom id,atom locs,atom indx,atom mat)

 c_proc(xSetShaderValueMatrix,{id,locs,indx,mat})
	
end procedure

public procedure SetShaderValueTexture(atom id,atom locs,atom idx,atom id2,atom w,atom h,atom mip,atom format)

 c_proc(xSetShaderValueTexture,{id,locs,idx,id2,w,h,mip,format})
	
end procedure

public procedure UnloadShader(atom id,atom locs)

 c_proc(xUnloadShader,{id,locs})
	
end procedure

--Screen-space Functions

public constant xGetMouseRay = define_c_func(ray,"+GetMouseRay",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_FLOAT),
				xGetCameraMatrix = define_c_func(ray,"+GetCameraMatrix",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_FLOAT),
				xGetCameraMatrix2D = define_c_func(ray,"+GetCameraMatrix2D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT),
				xGetWorldToScreen = define_c_func(ray,"+GetWorldToScreen",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_FLOAT),
				xGetWorldToScreenEx = define_c_func(ray,"+GetWorldToScreenEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT},C_FLOAT),
				xGetWorldToScreen2D = define_c_func(ray,"+GetWorldToScreen2D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT),
				xGetScreenToWorld2D = define_c_func(ray,"+GetScreenToWorld2D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)
				
public function GetMouseRay(atom x,atom y,atom px,atom py,atom pz,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj)

 return c_func(xGetMouseRay,{x,y,px,py,pz,tx,ty,tz,ux,uy,uz,fov,proj})
	
end function

public function GetCameraMatrix(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj)

 return c_func(xGetCameraMatrix,{x,y,z,tx,ty,tz,ux,uy,uz,fov,proj})
	
end function

public function GetCameraMatrix2D(atom x,atom y,atom tx,atom ty,atom rot,atom zoom)

 return c_func(xGetCameraMatrix2D,{x,y,tx,ty,rot,zoom})
	
end function

public function GetWorldToScreen(atom x,atom y,atom z,atom cx,atom cy,atom cz,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj)

 return c_func(xGetWorldToScreen,{x,y,z,cx,cy,cz,tx,ty,tz,ux,uy,uz,fov,proj})
	
end function

public function GetWorldToScreenEx(atom x,atom y,atom z,atom cx,atom cy,atom cz,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj,atom w,atom h)

 return c_func(xGetWorldToScreenEx,{x,y,z,cx,cy,cz,tx,ty,tz,ux,uy,uz,fov,proj,w,h})
	
end function

public function GetWorldToScreen2D(atom x,atom y,atom cx,atom cy,atom tx,atom ty,atom rot,atom zoom)

 return c_func(xGetWorldToScreen2D,{x,y,cx,cy,tx,ty,rot,zoom})
	
end function

public function GetScreenToWorld2D(atom x,atom y,atom cx,atom cy,atom tx,atom ty,atom rot,atom zoom)

 return c_func(xGetScreenToWorld2D,{x,y,cx,cy,tx,ty,rot,zoom})
	
end function

--Timing Functions

public constant xSetTargetFPS = define_c_proc(ray,"+SetTargetFPS",{C_INT}),
				xGetFPS = define_c_func(ray,"+GetFPS",{},C_INT),
				xGetFrameTime = define_c_func(ray,"+GetFrameTime",{},C_FLOAT),
				xGetTime = define_c_func(ray,"+GetTime",{},C_DOUBLE)
				
public procedure SetTargetFPS(atom fps)

 c_proc(xSetTargetFPS,{fps})
	
end procedure

public function GetFPS()

 return c_func(xGetFPS,{})
	
end function

public function GetFrameTime()

 return c_func(xGetFrameTime,{})
	
end function

public function GetTime()

 return c_func(xGetTime,{})
	
end function

--Misc functions

public constant xGetRandomValue = define_c_func(ray,"+GetRandomValue",{C_INT,C_INT},C_INT),
				xSetRandomSeed = define_c_proc(ray,"+SetRandomSeed",{C_UINT}),
				xTakeScreenshot = define_c_proc(ray,"+TakeScreenshot",{C_POINTER}),
				xSetConfigFlags = define_c_proc(ray,"+SetConfigFlags",{C_UINT})
				
public function GetRandomValue(atom min,atom max)

 return c_func(xGetRandomValue,{min,max})
	
end function

public procedure SetRandomSeed(atom sd)

 c_proc(xSetRandomSeed,{sd})
	
end procedure

public procedure TakeScreenshot(sequence file)

 atom str = allocate_string(file,1)
 
 c_proc(xTakeScreenshot,{str})
	
end procedure

public procedure SetConfigFlags(atom flags)

 c_proc(xSetConfigFlags,{flags})
	
end procedure

public constant xTraceLog = define_c_proc(ray,"+TraceLog",{C_INT,C_POINTER}),
				xSetTraceLogLevel = define_c_proc(ray,"+SetTraceLogLevel",{C_INT}),
				xMemAlloc = define_c_proc(ray,"+MemAlloc",{C_INT}),
				xMemRealloc = define_c_proc(ray,"+MemRealloc",{C_POINTER,C_INT}),
				xMemFree = define_c_proc(ray,"+MemFree",{C_POINTER})
				
public procedure TraceLog(atom loglvl,sequence text)

 atom str = allocate_string(text,1)
 
 c_proc(xTraceLog,{loglvl,str})
	
end procedure

public procedure SetTraceLogLevel(atom loglvl)

 c_proc(xSetTraceLogLevel,{loglvl})
	
end procedure

public procedure MemAlloc(atom size)

 c_proc(xMemAlloc,{size})
	
end procedure

public procedure MemRealloc(atom ptr,atom size)

 c_proc(xMemRealloc,{ptr,size})
	
end procedure

public procedure MemFree(atom ptr)

 c_proc(xMemFree,{ptr})
	
end procedure

--Custom Callback Functions

public constant xSetTraceLogCallback = define_c_proc(ray,"+SetTraceLogCallback",{C_POINTER}),
				xSetLoadFileDataCallback = define_c_proc(ray,"+SetLoadFileDataCallback",{C_POINTER}),
				xSetSaveFileDataCallback = define_c_proc(ray,"+SetSaveFileDataCallback",{C_POINTER}),
				xSetLoadFileTextCallback = define_c_proc(ray,"+SetLoadFileTextCallback",{C_POINTER}),
				xSetSaveFileTextCallback = define_c_proc(ray,"+SetSaveFileTextCallback",{C_POINTER})
				
public procedure SetTraceLogCallback(atom cb)

 c_proc(xSetTraceLogCallback,{cb})
	
end procedure

public procedure SetLoadFileDataCallback(atom cb)

 c_proc(xSetLoadFileDataCallback,{cb})
	
end procedure

public procedure SetSaveFileDataCallback(atom cb)

 c_proc(xSetSaveFileDataCallback,{cb})
	
end procedure

public procedure SetLoadFileTextCallback(atom cb)

 c_proc(xSetLoadFileTextCallback,{cb})
	
end procedure

public procedure SetSaveFileTextCallback(atom cb)

 c_proc(xSetSaveFileTextCallback,{cb})
	
end procedure

--File Functions

public constant xLoadFileData = define_c_func(ray,"+LoadFileData",{C_POINTER,C_POINTER},C_POINTER),
				xUnloadFileData = define_c_proc(ray,"+UnloadFileData",{C_POINTER}),
				xSaveFileData = define_c_func(ray,"+SaveFileData",{C_POINTER,C_POINTER,C_UINT},C_BOOL),
				xLoadFileText = define_c_func(ray,"+LoadFileText",{C_POINTER},C_POINTER),
				xUnloadFileText = define_c_proc(ray,"+UnloadFileText",{C_POINTER}),
				xSaveFileText = define_c_func(ray,"+SaveFileText",{C_POINTER,C_POINTER},C_BOOL),
				xFileExists = define_c_func(ray,"+FileExists",{C_POINTER},C_BOOL),
				xDirectoryExists = define_c_func(ray,"+DirectoryExists",{C_POINTER},C_BOOL),
				xIsFileExtension = define_c_func(ray,"+IsFileExtension",{C_POINTER,C_POINTER},C_BOOL),
				xGetFileExtension = define_c_func(ray,"+GetfileExtension",{C_POINTER},C_POINTER),
				xGetFileName = define_c_func(ray,"+GetfileName",{C_POINTER},C_POINTER),
				xGetFileNameWithoutExt = define_c_func(ray,"+GetFileNameWithoutExt",{C_POINTER},C_POINTER),
				xGetDirectoryPath = define_c_func(ray,"+GetDirectoryPath",{C_POINTER},C_POINTER),
				xGetPrevDirectoryPath = define_c_func(ray,"+GetPrevDirectoryPath",{C_POINTER},C_POINTER),
				xGetWorkingDirectory = define_c_func(ray,"+GetWorkingDirectory",{},C_POINTER),
				xGetDirectoryFiles = define_c_func(ray,"+GetDirectoryFiles",{C_POINTER,C_POINTER},C_POINTER),
				xClearDirectoryFiles = define_c_proc(ray,"+ClearDirectoryFiles",{}),
				xChangeDirectory = define_c_func(ray,"+ChangeDirectory",{C_POINTER},C_BOOL),
				xIsFileDropped = define_c_func(ray,"+IsFileDropped",{},C_BOOL),
				xGetDroppedFiles = define_c_func(ray,"+GetDroppedFiles",{C_POINTER},C_POINTER),
				xClearDroppedFiles = define_c_proc(ray,"+ClearDroppedFiles",{}),
				xGetFileModTime = define_c_func(ray,"+GetFileModTime",{C_POINTER},C_LONG)
				
public function LoadFileData(sequence file,atom br)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFileData,{str,br})
	
end function

public procedure UnloadFileData(atom dat)

 c_proc(xUnloadFileData,{dat})
	
end procedure

public function SaveFileData(sequence file,atom dat,atom bw)

 atom str = allocate_string(file,1)
 
 return c_func(xSaveFileData,{str,dat,bw})
	
end function

public function LoadFileText(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFileText,{str})
	
end function

public procedure UnloadFileText(sequence text)

 atom str = allocate_string(text,1)
 
 c_proc(xUnloadFileText,{str})
	
end procedure

public function SaveFileText(sequence file,atom text)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(text,1)
 
 return c_func(xSaveFileText,{str,str2})
	
end function

public function FileExists(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xFileExists,{str})
	
end function

public function DirectoryExists(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xDirectoryExists,{str})
	
end function

public function IsFileExtension(sequence file,sequence ex)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(ex,1)
 
 return c_func(xIsFileExtension,{str,str2})
	
end function

public function GetFileExtension(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetFileExtension,{str})
	
end function

public function GetFileName(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xGetFileName,{str})
	
end function

public function GetFileNameWithoutExt(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xGetFileNameWithoutExt,{str})
	
end function

public function GetDirectoryPath(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xGetDirectoryPath,{str})
	
end function

public function GetPrevDirectoryPath(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xGetPrevDirectoryPath,{str})
	
end function

public function GetWorkingDirectory()

 return c_func(xGetWorkingDirectory,{})
	
end function

public function GetDirectoryFiles(sequence path,atom count)

 atom str = allocate_string(path,1)
 
 return c_func(xGetDirectoryFiles,{str,count})
	
end function

public procedure ClearDirectoryFiles()

 c_proc(xClearDirectoryFiles,{})
	
end procedure

public function ChangeDirectory(sequence d)

 atom str = allocate_string(d,1)
 
 return c_func(xChangeDirectory,{str})
	
end function

public function IsFileDropped()

 return c_func(xIsFileDropped,{})
	
end function

public function GetDroppedFiles(atom cnt)

 return c_func(xGetDroppedFiles,{cnt})
	
end function

public procedure ClearDroppedFiles()

 c_proc(xClearDroppedFiles,{})
	
end procedure

public function GetFileModTime(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetFileModTime,{str})
	
end function

--Compression Functions

public constant xCompressData = define_c_func(ray,"+CompressData",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xDecompressData = define_c_func(ray,"+DecompressData",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xEncodeDataBase64 = define_c_func(ray,"+EncodeDataBase64",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xDecodeDataBase64 = define_c_func(ray,"+DecodeDataBase64",{C_POINTER,C_POINTER},C_POINTER)
				
public function CompressData(atom dat,atom len,atom datalen)

 return c_func(xCompressData,{dat,len,datalen})
	
end function

public function DecompressData(atom dat,atom len,atom datalen)
 
 return c_func(xDecompressData,{dat,len,datalen})
	
end function

public function EncodeDataBase64(atom dat,atom len,atom putlen)

 return c_func(xEncodeDataBase64,{dat,len,putlen})
	
end function

public function DecodeDataBase64(atom dat,atom putlen)

 return c_func(xDecodeDataBase64,{dat,putlen})
	
end function

--Storage Functions

public constant xSaveStorageValue = define_c_func(ray,"+SaveStorageValue",{C_UINT,C_INT},C_BOOL),
				xLoadStorageValue = define_c_func(ray,"+LoadStorageValue",{C_UINT},C_INT)
				
public function SaveStorageValue(atom pos,atom val)

 return c_func(xSaveStorageValue,{pos,val})
	
end function

public function LoadStorageValue(atom pos)

 return c_func(xLoadStorageValue,{pos})
	
end function

public constant xOpenURL = define_c_proc(ray,"+OpenURL",{C_POINTER})

public procedure OpenURL(sequence url)

 atom str = allocate_string(url,1)
 
 c_proc(xOpenURL,{str})
	
end procedure

--Keyboard Functions

public constant xIsKeyPressed = define_c_func(ray,"+IsKeyPressed",{C_INT},C_BOOL),
				xIsKeyDown = define_c_func(ray,"+IsKeyDown",{C_INT},C_BOOL),
				xIsKeyReleased = define_c_func(ray,"+IsKeyReleased",{C_INT},C_BOOL),
				xIsKeyUp = define_c_func(ray,"+IsKeyUp",{C_INT},C_BOOL),
				xSetExitKey = define_c_proc(ray,"+SetExitKey",{C_INT}),
				xGetKeyPressed = define_c_func(ray,"+GetKeyPressed",{},C_INT),
				xGetCharPressed = define_c_func(ray,"+GetCharPressed",{},C_INT)
				
public function IsKeyPressed(atom key)

 return c_func(xIsKeyPressed,{key})
	
end function

public function IsKeyDown(atom key)

 return c_func(xIsKeyDown,{key})
	
end function

public function IsKeyReleased(atom key)

 return c_func(xIsKeyReleased,{key})
	
end function

public function IsKeyUp(atom key)

 return c_func(xIsKeyUp,{key})
	
end function

public procedure SetExitKey(atom key)

 c_proc(xSetExitKey,{key})
	
end procedure

public function GetKeyPressed()

 return c_func(xGetKeyPressed,{})
	
end function

public function GetCharPressed()

 return c_func(xGetCharPressed,{})
	
end function

--Gamepad Functions

public constant xIsGamepadAvailable = define_c_func(ray,"+IsGamepadAvailable",{C_INT},C_BOOL),
				xGetGamepadName = define_c_func(ray,"+GetGamepadName",{C_INT},C_POINTER),
				xIsGamepadButtonPressed = define_c_func(ray,"+IsGamepadButtonPressed",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonDown = define_c_func(ray,"+IsGamepadButtonDown",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonReleased = define_c_func(ray,"+IsGamepadButtonReleased",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonUp = define_c_func(ray,"+IsGamepadButtonUp",{C_INT,C_INT},C_BOOL),
				xGetGamepadButtonPressed = define_c_func(ray,"+GetGamepadButtonPressed",{},C_INT),
				xGetGamepadAxisCount = define_c_func(ray,"+GetGamepadAxisCount",{C_INT},C_INT),
				xGetGamepadAxisMovement = define_c_func(ray,"+GetGamepadAxisMovement",{C_INT,C_INT},C_FLOAT),
				xSetGamepadMappings = define_c_func(ray,"+SetGamepadMappings",{C_POINTER},C_INT)
				
public function IsGamepadAvailable(atom gp)

 return c_func(xIsGamepadAvailable,{gp})
	
end function

public function GetGamepadName(atom gp)

 return c_func(xGetGamepadName,{gp})
	
end function

public function IsGamepadButtonPressed(atom gp,atom b)

 return c_func(xIsGamepadButtonPressed,{gp,b})
	
end function

public function IsGamepadButtonDown(atom gp,atom b)

 return c_func(xIsGamepadButtonDown,{gp,b})
	
end function

public function IsGamepadButtonReleased(atom gp,atom b)

 return c_func(xIsGamepadButtonReleased,{gp,b})
	
end function

public function IsGamepadButtonUp(atom gp,atom b)

 return c_func(xIsGamepadButtonUp,{gp,b})
	
end function

public function GetGamepadButtonPressed()

 return c_func(xGetGamepadButtonPressed,{})
	
end function

public function GetGamepadAxisCount(atom gp)

 return c_func(xGetGamepadAxisCount,{gp})
	
end function

public function GetGamepadAxisMovement(atom gp,atom ax)

 return c_func(xGetGamepadAxisMovement,{gp,ax})
	
end function

public function SetGamepadMappings(sequence mapp)

 atom str = allocate_string(mapp,1)
 
 return c_func(xSetGamepadMappings,{str})
	
end function

--Mouse Functions

public constant xIsMouseButtonPressed = define_c_func(ray,"+IsMouseButtonPressed",{C_INT},C_BOOL),
				xIsMouseButtonDown = define_c_func(ray,"+IsMouseButtonDown",{C_INT},C_BOOL),
				xIsMouseButtonReleased = define_c_func(ray,"+IsMouseButtonReleased",{C_INT},C_BOOL),
				xIsMouseButtonUp = define_c_func(ray,"+IsMouseButtonUp",{C_INT},C_BOOL),
				xGetMouseX = define_c_func(ray,"+GetMouseX",{},C_INT),
				xGetMouseY = define_c_func(ray,"+GetMouseY",{},C_INT),
				xGetMousePosition = define_c_func(ray,"+GetMousePosition",{},C_FLOAT),
				xGetMouseDelta = define_c_func(ray,"+GetMouseDelta",{},C_FLOAT),
				xSetMousePosition = define_c_proc(ray,"+SetMousePosition",{C_INT,C_INT}),
				xSetMouseOffset = define_c_proc(ray,"+SetMouseOffset",{C_INT,C_INT}),
				xSetMouseScale = define_c_proc(ray,"+SetMouseScale",{C_FLOAT,C_FLOAT}),
				xGetMouseWheelMove = define_c_func(ray,"+GetMouseWheelMove",{},C_FLOAT),
				xSetMouseCursor = define_c_proc(ray,"+SetMouseCursor",{C_INT})
				
public function IsMouseButtonPressed(atom b)

 return c_func(xIsMouseButtonPressed,{b})
	
end function

public function IsMouseButtonDown(atom b)

 return c_func(xIsMouseButtonDown,{b})
	
end function

public function IsMouseButtonReleased(atom b)

 return c_func(xIsMouseButtonReleased,{b})
	
end function

public function IsMouseButtonUp(atom b)

 return c_func(xIsMouseButtonUp,{b})
	
end function

public function GetMouseX()

 return c_func(xGetMouseX,{})
	
end function

public function GetMouseY()

 return c_func(xGetMouseY,{})
	
end function

public function GetMousePosition()

 return c_func(xGetMousePosition,{})
	
end function

public function GetMouseDelta()

 return c_func(xGetMouseDelta,{})
	
end function

public procedure SetMousePosition(atom x,atom y)

 c_proc(xSetMousePosition,{x,y})
	
end procedure

public procedure SetMouseOffset(atom x,atom y)

 c_proc(xSetMouseOffset,{x,y})
	
end procedure

public procedure SetMouseScale(atom x,atom y)

 c_proc(xSetMouseScale,{x,y})
	
end procedure

public function GetMouseWheelMove()

 return c_func(xGetMouseWheelMove,{})
	
end function

public procedure SetMouseCursor(atom cur)

 c_proc(xSetMouseCursor,{cur})
	
end procedure

--Touch Functions

public constant xGetTouchX = define_c_func(ray,"+GetTouchX",{},C_INT),
				xGetTouchY = define_c_func(ray,"+GetTouchY",{},C_INT),
				xGetTouchPosition = define_c_func(ray,"+GetTouchPosition",{C_INT},C_FLOAT),
				xGetTouchPointId = define_c_func(ray,"+GetTouchPointId",{C_INT},C_INT),
				xGetTouchPointCount = define_c_func(ray,"+GetTouchPointCount",{},C_INT)
				
public function GetTouchX()

 return c_func(xGetTouchX,{})
	
end function

public function GetTouchY()

 return c_func(xGetTouchY,{})
	
end function

public function GetTouchPosition(atom i)

 return c_func(xGetTouchPosition,{i})
	
end function

public function GetTouchPointId(atom i)

 return c_func(xGetTouchPointId,{i})
	
end function

public function GetTouchPointCount()

 return c_func(xGetTouchPointCount,{})
	
end function

--Gesture Functions

public constant xSetGesturesEnabled = define_c_proc(ray,"+SetGesturesEnabled",{C_UINT}),
				xIsGestureDetected = define_c_func(ray,"+IsGestureDetected",{C_INT},C_BOOL),
				xGetGestureDetected = define_c_func(ray,"+GetGestureDetected",{},C_INT),
				xGetGestureHoldDuration = define_c_func(ray,"+GetGestureHoldDuration",{},C_FLOAT),
				xGetGestureDragVector = define_c_func(ray,"+GetGestureDragVector",{},C_FLOAT),
				xGetGestureDragAngle = define_c_func(ray,"+GetGestureDragAngle",{},C_FLOAT),
				xGetGesturePinchVector = define_c_func(ray,"+GetGesturePinchVector",{},C_FLOAT),
				xGetGesturePinchAngle = define_c_func(ray,"+GetGesturePinchAngle",{},C_FLOAT)
				
public procedure SetGesturesEnabled(atom flags)

 c_proc(xSetGesturesEnabled,{flags})
	
end procedure

public function IsGestureDetected(atom ges)

 return c_func(xIsGestureDetected,{ges})
	
end function

public function GetGestureDetected()

 return c_func(xGetGestureDetected,{})
	
end function

public function GetGestureHoldDuration()

 return c_func(xGetGestureHoldDuration,{})
	
end function

public function GetGestureDragVector()

 return c_func(xGetGestureDragVector,{})
	
end function

public function GetGestureDragAngle()

 return c_func(xGetGestureDragAngle,{})
	
end function

public function GetGesturePinchVector()

 return c_func(xGetGesturePinchVector,{})
	
end function

public function GetGesturePinchAngle()

 return c_func(xGetGesturePinchAngle,{})
	
end function

--Camera Functions

public constant xSetCameraMode = define_c_proc(ray,"+SetCameraMode",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT}),
				xUpdateCamera = define_c_proc(ray,"+UpdateCamera",{C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER})
				
public procedure SetCameraMode(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj,atom mode)

 c_proc(xSetCameraMode,{x,y,z,tx,ty,tz,ux,uy,uz,proj,fov,mode})
	
end procedure
				
public procedure UpdateCamera(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom proj,atom fov)

 c_proc(xUpdateCamera,{x,y,z,tx,ty,tz,ux,uy,uz,proj,fov})
	
end procedure
				
public constant xSetCameraPanControl = define_c_proc(ray,"+SetCameraPanControl",{C_INT}),
				xSetCameraAltControl = define_c_proc(ray,"+SetCameraAltControl",{C_INT}),
				xSetCameraSmoothZoomControl = define_c_proc(ray,"+SetCameraSmoothZoomControl",{C_INT}),
				xSetCameraMoveControls = define_c_proc(ray,"+SetCameraMoveControls",{C_INT,C_INT,C_INT,C_INT,C_INT,C_INT})
				
public procedure SetCameraPanControl(atom kpan)

 c_proc(xSetCameraPanControl,{kpan})
	
end procedure

public procedure SetCameraAltControl(atom kalt)

 c_proc(xSetCameraAltControl,{kalt})
	
end procedure

public procedure SetCameraSmoothZoomControl(atom keyzoom)

 c_proc(xSetCameraSmoothZoomControl,{keyzoom})
	
end procedure

public procedure SetCameraMoveControls(atom kf,atom kb,atom kr,atom kl,atom ku,atom kd)

 c_proc(xSetCameraMoveControls,{kf,kb,kr,kl,ku,kd})
	
end procedure

--Shape Drawing Functions

public constant xSetShapesTexture = define_c_proc(ray,"+SetShapesTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT})

public procedure SetShapesTexture(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom rw,atom rh)

 c_proc(xSetShapesTexture,{id,w,h,mip,format,x,y,rw,rh})
	
end procedure

--Basic Shape Functions

public constant xDrawPixel = define_c_proc(ray,"+DrawPixel",{C_INT,C_INT,C_UINT}),
				xDrawPixelV = define_c_proc(ray,"+DrawPixelV",{C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLine = define_c_proc(ray,"+DrawLine",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawLineV = define_c_proc(ray,"+DrawLineV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineEx = define_c_proc(ray,"+DrawLineEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineBezier = define_c_proc(ray,"+DrawLineBezier",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineBezierQuad = define_c_proc(ray,"+DrawLineBezierQuad",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineBezierCubic = define_c_proc(ray,"+DrawLineBezierCubic",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineStrip = define_c_proc(ray,"+DrawLineStrip",{C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawCircle = define_c_proc(ray,"+DrawCircle",{C_INT,C_INT,C_FLOAT,C_UINT}),
				xDrawCircleSector = define_c_proc(ray,"+DrawCircleSector",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCircleSectorLines = define_c_proc(ray,"+DrawCircleSectorLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCircleGradient = define_c_proc(ray,"+DrawCircleGradient",{C_INT,C_INT,C_FLOAT,C_UINT,C_UINT}),
				xDrawCircleV = define_c_proc(ray,"+DrawCircleV",{C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCircleLines = define_c_proc(ray,"+DrawCircleLins",{C_INT,C_INT,C_FLOAT,C_UINT}),
				xDrawEllipse = define_c_proc(ray,"+DrawEllipse",{C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawEllipseLines = define_c_proc(ray,"+DrawEllipseLines",{C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRing = define_c_proc(ray,"+DrawRing",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawRingLines = define_c_proc(ray,"+DrawRingLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawRectangle = define_c_proc(ray,"+DrawRectangle",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRectangleV = define_c_proc(ray,"+DrawRectangleV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectangleRec = define_c_proc(ray,"+DrawRectangleRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectanglePro = define_c_proc(ray,"+DrawRectanglePro",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectangleGradientV = define_c_proc(ray,"+DrawRectangleGradientV",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT}),
				xDrawRectangleGradientH = define_c_proc(ray,"+DrawRectangleGradientH",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT}),
				xDrawRectangleGradientEx = define_c_proc(ray,"+DrawRectangleGradientEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT,C_UINT,C_UINT,C_UINT}),
				xDrawRectangleLines = define_c_proc(ray,"+DrawRectangleLines",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRectangleLinesEx = define_c_proc(ray,"+DrawRectangleLinesEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectangleRounded = define_c_proc(ray,"+DrawRectangleRounded",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawRectangleRoundedLines = define_c_proc(ray,"+DrawRectangleRoundedLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_UINT}),
				xDrawTriangle = define_c_proc(ray,"+DrawTriangle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangleLines = define_c_proc(ray,"+DrawTriangleLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangleFan = define_c_proc(ray,"+DrawTriangleFan",{C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawTriangleStrip = define_c_proc(ray,"+DrawTriangleStrip",{C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawPoly = define_c_proc(ray,"+DrawPoly",{C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawPolyLines = define_c_proc(ray,"+DrawPolyLines",{C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawPolyLinesEx = define_c_proc(ray,"+DrawPolyLinesEx",{C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawPixel(atom x,atom y,atom col)

 c_proc(xDrawPixel,{x,y,col})
	
end procedure

public procedure DrawPixelV(atom x,atom y,atom col)

 c_proc(xDrawPixelV,{x,y,col})
	
end procedure

public procedure DrawLine(atom x,atom y,atom ex,atom ey,atom col)

 c_proc(xDrawLine,{x,y,ex,ey,col})
	
end procedure

public procedure DrawLineV(atom x,atom y,atom ex,atom ey,atom col)

 c_proc(xDrawLineV,{x,y,ex,ey,col})
	
end procedure

public procedure DrawLineEx(atom x,atom y,atom ex,atom ey,atom thick,atom col)

 c_proc(xDrawLineEx,{x,y,ex,ey,thick,col})
	
end procedure

public procedure DrawLineBezier(atom x,atom y,atom ex,atom ey,atom thick,atom col)

 c_proc(xDrawLineBezier,{x,y,ex,ey,thick,col})
	
end procedure

public procedure DrawLineBezierQuad(atom x,atom y,atom ex,atom ey,atom cx,atom cy,atom thick,atom col)

 c_proc(xDrawLineBezierQuad,{x,y,ex,ey,cx,cy,thick,col})
	
end procedure

public procedure DrawLineBezierCubic(atom x,atom y,atom ex,atom ey,atom cx,atom cy,atom cex,atom cey,atom thick,atom col)

 c_proc(xDrawLineBezierCubic,{x,y,ex,ey,cx,cy,cex,cey,thick,col})
	
end procedure

public procedure DrawLineStrip(atom x,atom y,atom pt,atom col)

 c_proc(xDrawLineStrip,{x,y,pt,col})
	
end procedure

public procedure DrawCircle(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircle,{x,y,rad,col})
	
end procedure

public procedure DrawCircleSector(atom x,atom y,atom rad,atom sa,atom ea,atom seg,atom col)

 c_proc(xDrawCircleSector,{x,y,rad,sa,ea,seg,col})
	
end procedure

public procedure DrawCircleSectorLines(atom x,atom y,atom rad,atom sa,atom ea,atom seg,atom col)

 c_proc(xDrawCircleSectorLines,{x,y,rad,sa,ea,seg,col})
	
end procedure

public procedure DrawCircleGradient(atom x,atom y,atom rad,atom col,atom col2)

 c_proc(xDrawCircleGradient,{x,y,rad,col,col2})
	
end procedure

public procedure DrawCircleV(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircleV,{x,y,rad,col})
	
end procedure

public procedure DrawCircleLines(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircleLines,{x,y,rad,col})
	
end procedure

public procedure DrawEllipse(atom x,atom y,atom rh,atom rv,atom col)

 c_proc(xDrawEllipse,{x,y,rh,rv,col})
	
end procedure

public procedure DrawEllipseLines(atom x,atom y,atom rh,atom rv,atom col)

 c_proc(xDrawEllipseLines,{x,y,rh,rv,col})
	
end procedure

public procedure DrawRing(atom x,atom y,atom ir,atom orr,atom sa,atom ea,atom seg,atom col)

 c_proc(xDrawRing,{x,y,ir,orr,sa,ea,seg,col})
	
end procedure

public procedure DrawRingLines(atom x,atom y,atom ir,atom orr,atom sa,atom ea,atom seg,atom col)

 c_proc(xDrawRingLines,{x,y,ir,orr,sa,ea,seg,col})
	
end procedure

public procedure DrawRectangle(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangle,{x,y,w,h,col})
	
end procedure

public procedure DrawRectangleV(atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xDrawRectangleV,{x,y,x2,y2,col})
	
end procedure

public procedure DrawRectangleRec(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangleRec,{x,y,w,h,col})
	
end procedure

public procedure DrawRectanglePro(atom x,atom y,atom w,atom h,atom x2,atom y2,atom rot,atom col)

 c_proc(xDrawRectanglePro,{x,y,w,h,x2,y2,rot,col})
	
end procedure

public procedure DrawRectangleGradientV(atom x,atom y,atom w,atom h,atom col,atom col2)

 c_proc(xDrawRectangleGradientV,{x,y,w,h,col,col2})
	
end procedure

public procedure DrawRectangleGradientH(atom x,atom y,atom w,atom h,atom col,atom col2)

 c_proc(xDrawRectangleGradientH,{x,y,w,h,col,col2})
	
end procedure

public procedure DrawRectangleGradientEx(atom x,atom y,atom w,atom h,atom col,atom col2,atom col3,atom col4)

 c_proc(xDrawRectangleGradientEx,{x,y,w,h,col,col2,col3,col4})
	
end procedure

public procedure DrawRectangleLines(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangleLines,{x,y,w,h,col})
	
end procedure

public procedure DrawRectangleLinesEx(atom x,atom y,atom w,atom h,atom thick,atom col)

 c_proc(xDrawRectangleLinesEx,{x,y,w,h,thick,col})
	
end procedure

public procedure DrawRectangleRounded(atom x,atom y,atom w,atom h,atom round,atom seg,atom col)

 c_proc(xDrawRectangleRounded,{x,y,w,h,round,seg,col})
	
end procedure

public procedure DrawRectangleRoundedLines(atom x,atom y,atom w,atom h,atom round,atom seg,atom thick,atom col)

 c_proc(xDrawRectangleRoundedLines,{x,y,w,h,round,seg,thick,col})
	
end procedure

public procedure DrawTriangle(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom col)

 c_proc(xDrawTriangle,{x,y,x2,y2,x3,y3,col})
	
end procedure

public procedure DrawTriangleLines(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom col)

 c_proc(xDrawTriangleLines,{x,y,x2,y2,x3,y3,col})
	
end procedure

public procedure DrawTriangleFan(atom x,atom y,atom pt,atom col)

 c_proc(xDrawTriangleFan,{x,y,pt,col})
	
end procedure

public procedure DrawTriangleStrip(atom x,atom y,atom pt,atom col)

 c_proc(xDrawTriangleStrip,{x,y,pt,col})
	
end procedure

public procedure DrawPoly(atom x,atom y,atom sides,atom rad,atom rot,atom col)

 c_proc(xDrawPoly,{x,y,sides,rad,rot,col})
	
end procedure

public procedure DrawPolyLines(atom x,atom y,atom sides,atom rad,atom rot,atom col)

 c_proc(xDrawPolyLines,{x,y,sides,rad,rot,col})
	
end procedure

public procedure DrawPolyLinesEx(atom x,atom y,atom sides,atom rad,atom rot,atom thick,atom col)

 c_proc(xDrawPolyLinesEx,{x,y,sides,rad,rot,thick,col})
	
end procedure

--Basic Shape Collision Functions

public constant xCheckCollisionRecs = define_c_func(ray,"+CheckCollisionRecs",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionCircles = define_c_func(ray,"+CheckCollisionCircles",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionCircleRec = define_c_func(ray,"+CheckCollisionCircleRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionPointRec = define_c_func(ray,"+CheckCollisionPointRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionPointCircle = define_c_func(ray,"+CheckCollisionPointCircle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionPointTriangle = define_c_func(ray,"+CheckCollisionPointTriangle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionLines = define_c_func(ray,"+CheckCollisionLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER},C_BOOL),
				xCheckCollisionPointLine = define_c_func(ray,"+CheckCollisionPointLine",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_BOOL),
				xGetCollisionRec = define_c_func(ray,"+GetCollisionRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)
				
public function CheckCollisionRecs(atom x,atom y,atom w,atom h,atom x2,atom y2,atom w2,atom h2)

 return c_func(xCheckCollisionRecs,{x,y,w,h,x2,y2,w2,h2})
	
end function

public function CheckCollisionCircles(atom x,atom y,atom rad,atom x2,atom y2,atom rad2)

 return c_func(xCheckCollisionCircles,{x,y,rad,x2,y2,rad2})
	
end function

public function CheckCollisionCircleRec(atom x,atom y,atom rad,atom x2,atom y2,atom w,atom h)

 return c_func(xCheckCollisionCircleRec,{x,y,rad,x2,y2,w,h})
	
end function

public function CheckCollisionPointRec(atom x,atom y,atom x2,atom y2,atom w,atom h)

 return c_func(xCheckCollisionPointRec,{x,y,x2,y2,w,h})
	
end function

public function CheckCollisionPointCircle(atom x,atom y,atom x2,atom y2,atom rad)

 return c_func(xCheckCollisionPointCircle,{x,y,x2,y2,rad})
	
end function

public function CheckCollisionPointTriangle(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom x4,atom y4)

 return c_func(xCheckCollisionPointTriangle,{x,y,x2,y2,x3,y3,x4,y4})
	
end function

public function CheckCollisionLines(atom x,atom y,atom ex,atom ey,atom x2,atom y2,atom ex2,atom ey2,atom px,atom py)

 return c_func(xCheckCollisionLines,{x,y,ex,ey,x2,y2,ex2,ey2,px,py})
	
end function

public function CheckCollisionPointLine(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom thres)

 return c_func(xCheckCollisionPointLine,{x,y,x2,y2,x3,y3,thres})
	
end function

public function GetCollisionRec(atom x,atom y,atom w,atom h,atom x2,atom y2,atom w2,atom h2)

 return c_func(xGetCollisionRec,{x,y,w,h,x2,y2,w2,h2})
	
end function

--Image Loading Functions

public constant xLoadImage = define_c_func(ray,"+LoadImage",{C_POINTER},C_POINTER),
				xLoadImageRaw = define_c_func(ray,"+LoadImageRaw",{C_POINTER,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xLoadImageAnim = define_c_func(ray,"+LoadImageAnim",{C_POINTER,C_POINTER},C_POINTER),
				xLoadImageFromMemory = define_c_func(ray,"+LoadImageFromMemory",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xLoadImageFromTexture = define_c_func(ray,"+LoadImageFromTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xLoadImageFromScreen = define_c_func(ray,"+LoadImageFromScreen",{},C_POINTER),
				xUnloadImage = define_c_proc(ray,"+UnloadImage",{C_POINTER,C_INT,C_INT,C_INT,C_INT}),
				xExportImage = define_c_func(ray,"+ExportImage",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_POINTER},C_BOOL),
				xExportImageAsCode = define_c_func(ray,"+ExportImageAsCode",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_POINTER},C_BOOL)
				
public function LoadImage(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImage,{str})
	
end function

public function LoadImageRaw(sequence file,atom w,atom h,atom format,atom size)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImageRaw,{str,w,h,format,size})
	
end function

public function LoadImageAnim(sequence file,atom frames)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImageAnim,{str,frames})
	
end function

public function LoadImageFromMemory(sequence file,atom data,atom size)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImageFromMemory,{str,data,size})
	
end function

public function LoadImageFromTexture(atom id,atom w,atom h,atom mip,atom format)

 return c_func(xLoadImageFromTexture,{id,w,h,mip,format})
	
end function

public function LoadImageFromScreen()

 return c_func(xLoadImageFromScreen,{})
	
end function

public procedure UnloadImage(atom dat,atom w,atom h,atom mip,atom format)

 c_proc(xUnloadImage,{dat,w,h,mip,format})
	
end procedure

public function ExportImage(atom dat,atom w,atom h,atom mip,atom format,sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xExportImage,{dat,w,h,mip,format,str})
	
end function

public function ExportImageAsCode(atom dat,atom w,atom h,atom mip,atom format,sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xExportImageAsCode,{dat,w,h,mip,format,str})
	
end function

--Image Generation Functions

public constant xGenImageColor = define_c_func(ray,"+GenImageColor",{C_INT,C_INT,C_UINT},C_POINTER),
				xGenImageGradientV = define_c_func(ray,"+GenImageGradientV",{C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageGradientH = define_c_func(ray,"+GenImageGradientH",{C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageGradientRadial = define_c_func(ray,"+GenImageGradientRadial",{C_INT,C_INT,C_FLOAT,C_UINT,C_UINT},C_POINTER),
				xGenImageChecked = define_c_func(ray,"+GenImageChecked",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageWhiteNoise = define_c_func(ray,"+GenImageWhiteNoise",{C_INT,C_INT,C_FLOAT},C_POINTER),
				xGenImageCellular = define_c_func(ray,"+GenImageCellular",{C_INT,C_INT,C_INT},C_POINTER)
				
public function GenImageColor(atom w,atom h,atom col)

 return c_func(xGenImageColor,{w,h,col})
	
end function

public function GenImageGradientV(atom w,atom h,atom col, atom col2)

 return c_func(xGenImageGradientV,{w,h,col,col2})
	
end function

public function GenImageGradientH(atom w,atom h,atom col, atom col2)

 return c_func(xGenImageGradientH,{w,h,col,col2})
	
end function

public function GenImageGradientRadial(atom w,atom h,atom dens,atom col, atom col2)

 return c_func(xGenImageGradientRadial,{w,h,dens,col,col2})
	
end function

public function GenImageChecked(atom w,atom h,atom x,atom y,atom col, atom col2)

 return c_func(xGenImageChecked,{w,h,x,y,col,col2})
	
end function

public function GenImageWhiteNoise(atom w,atom h,atom factor)

 return c_func(xGenImageWhiteNoise,{w,h,factor})
	
end function

public function GenImageCellular(atom w,atom h,atom size)

 return c_func(xGenImageCellular,{w,h,size})
	
end function

--Image Manipulation Functions

public constant xImageCopy = define_c_func(ray,"+ImageCopy",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xImageFromImage = define_c_func(ray,"+ImageFromImage",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xImageText = define_c_func(ray,"+ImageText",{C_POINTER,C_INT,C_UINT},C_POINTER),
				xImageTextEx = define_c_func(ray,"+ImageTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_UINT},C_POINTER),
				xImageFormat = define_c_proc(ray,"+ImageFormat",{C_POINTER,C_INT}),
				xImageToPOT = define_c_proc(ray,"+ImageToPOT",{C_POINTER,C_UCHAR,C_UINT}),
				xImageCrop = define_c_proc(ray,"+ImageCrop",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT}),
				xImageAlphaCrop = define_c_proc(ray,"+ImageAlphaCrop",{C_POINTER,C_FLOAT}),
				xImageAlphaClear = define_c_proc(ray,"+ImageAlphaClear",{C_POINTER,C_UINT,C_FLOAT}),
				xImageAlphaMask = define_c_proc(ray,"+ImageAlphaMask",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT}),
				xImageAlphaPremultiply = define_c_proc(ray,"+ImageAlphaPremultiply",{C_POINTER}),
				xImageResize = define_c_proc(ray,"+ImageResize",{C_POINTER,C_INT,C_INT}),
				xImageResizeNN = define_c_proc(ray,"+ImageResizeNN",{C_POINTER,C_INT,C_INT}),
				xImageResizeCanvas = define_c_proc(ray,"+ImageResizeCanvas",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xImageMipmaps = define_c_proc(ray,"+ImageMipmaps",{C_POINTER}),
				xImageDither = define_c_proc(ray,"+ImageDither",{C_POINTER,C_INT,C_INT,C_INT,C_INT}),
				xImageFlipVertical = define_c_proc(ray,"+ImageFlipVertical",{C_POINTER}),
				xImageFlipHorizontal = define_c_proc(ray,"+ImageFlipHorizontal",{C_POINTER}),
				xImageRotateCW = define_c_proc(ray,"+ImageRotateCW",{C_POINTER}),
				xImageRotateCCW = define_c_proc(ray,"+ImageRotateCCW",{C_POINTER}),
				xImageColorTint = define_c_proc(ray,"+ImageColorTint",{C_POINTER,C_UINT}),
				xImageColorInvert = define_c_proc(ray,"+ImageColorInvert",{C_POINTER}),
				xImageColorGrayscale = define_c_proc(ray,"+ImageColorGrayscale",{C_POINTER}),
				xImageColorContrast = define_c_proc(ray,"+ImageColorContrast",{C_POINTER,C_FLOAT}),
				xImageColorBrightness = define_c_proc(ray,"+ImageColorBrightness",{C_POINTER,C_INT}),
				xImageColorReplace = define_c_proc(ray,"+ImageColorReplace",{C_POINTER,C_UINT,C_UINT}),
				xLoadImageColors = define_c_func(ray,"+LoadImageColors",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xLoadImagePalette = define_c_func(ray,"+LoadImagePalette",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_POINTER},C_POINTER),
				xUnloadImageColors = define_c_proc(ray,"+UnloadImageColors",{C_POINTER}),
				xUnloadImagePalette = define_c_proc(ray,"+UnloadImagePalette",{C_POINTER}),
				xGetImageAlphaBorder = define_c_func(ray,"+GetImageAlphaBorder",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT},C_FLOAT),
				xGetImageColor = define_c_func(ray,"+GetImageColor",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT},C_UINT)
				
public function ImageCopy(atom dat,atom w,atom h,atom mip,atom format)

 return c_func(xImageCopy,{dat,w,h,mip,format})
	
end function

public function ImageFromImage(atom dat,atom w,atom h,atom mip,atom format,atom x,atom y,atom rw,atom rh)

 return c_func(xImageFromImage,{dat,w,h,mip,format,x,y,rw,rh})
	
end function

public function ImageText(sequence text,atom size,atom col)

 atom str = allocate_string(text,1)
 
 return c_func(xImageText,{str,size,col})
	
end function

public function ImageTextEx(atom font,sequence text,atom size,atom space,atom col)

 atom str = allocate_string(text,1)
 
 return c_func(xImageTextEx,{font,str,size,space,col})
	
end function

public procedure ImageFormat(atom img,atom nformat)

 c_proc(xImageFormat,{img,nformat})
	
end procedure

public procedure ImageToPOT(atom img,atom col)

 c_proc(xImageToPOT,{img,col})
	
end procedure

public procedure ImageCrop(atom img,atom x,atom y,atom w,atom h)

 c_proc(xImageCrop,{img,x,y,w,h})
	
end procedure

public procedure ImageAlphaCrop(atom img,atom thres)

 c_proc(xImageAlphaCrop,{img,thres})
	
end procedure

public procedure ImageAlphaClear(atom img,atom col,atom thres)

 c_proc(xImageAlphaClear,{img,col,thres})
	
end procedure

public procedure ImageAlphaMask(atom img,atom dat,atom w,atom h,atom mip,atom format)

 c_proc(xImageAlphaMask,{img,dat,w,h,mip,format})
	
end procedure

public procedure ImageAlphaPremultiply(atom img)

 c_proc(xImageAlphaPremultiply,{img})
	
end procedure

public procedure ImageResize(atom img,atom w,atom h)

 c_proc(xImageResize,{img,w,h})
	
end procedure

public procedure ImageResizeNN(atom img,atom w,atom h)

 c_proc(xImageResizeNN,{img,w,h})
	
end procedure

public procedure ImageResizeCanvas(atom img,atom w,atom h,atom x,atom y,atom col)

 c_proc(xImageResizeCanvas,{img,w,h,x,y,col})
	
end procedure

public procedure ImageMipmaps(atom img)

 c_proc(xImageMipmaps,{img})
	
end procedure

public procedure ImageDither(atom img,atom col)

 c_proc(xImageDither,{img,col})
	
end procedure

public procedure ImageFlipVertical(atom img)

 c_proc(xImageFlipVertical,{img})
	
end procedure

public procedure ImageFlipHorizontal(atom img)

 c_proc(xImageFlipHorizontal,{img})
	
end procedure

public procedure ImageRotateCW(atom img)

 c_proc(xImageRotateCW,{img})
	
end procedure

public procedure ImageRotateCCW(atom img)

 c_proc(xImageRotateCCW,{img})
	
end procedure

public procedure ImageColorTint(atom img,atom col)

 c_proc(xImageColorTint,{img,col})
	
end procedure

public procedure ImageColorInvert(atom img)

 c_proc(xImageColorInvert,{img})
	
end procedure

public procedure ImageColorGrayscale(atom img)

 c_proc(xImageColorGrayscale,{img})
	
end procedure

public procedure ImageColorContrast(atom img,atom con)

 c_proc(xImageColorContrast,{img,con})
	
end procedure

public procedure ImageColorBrightness(atom img,atom bright)

 c_proc(xImageColorBrightness,{img,bright})
	
end procedure

public procedure ImageColorReplace(atom img,atom col, atom col2)

 c_proc(xImageColorReplace,{img,col,col2})
	
end procedure

public function LoadImageColors(atom dat,atom w,atom h,atom mip,atom format)

 return c_func(xLoadImageColors,{dat,w,h,mip,format})
	
end function

public function LoadImagePalette(atom dat,atom w,atom h,atom mip,atom format,atom maxsize,atom cnt)

 return c_func(xLoadImagePalette,{dat,w,h,mip,format,maxsize,cnt})
	
end function

public procedure UnloadImageColors(atom col)
 
 c_proc(xUnloadImageColors,{col})
	
end procedure

public procedure UnloadImagePalette(atom col)

 c_proc(xUnloadImagePalette,{col})
	
end procedure

public function GetImageAlphaBorder(atom dat,atom w,atom h,atom mip,atom format,atom thres)

 return c_func(xGetImageAlphaBorder,{dat,w,h,mip,format,thres})
	
end function

public function GetImageColor(atom dat,atom w,atom h,atom mip,atom format,atom x,atom y)

 return c_func(xGetImageColor,{dat,w,h,mip,format,x,y})
	
end function

--Image Drawing Functions

public constant xImageClearBackground = define_c_proc(ray,"+ImageClearBackground",{C_POINTER,C_UINT}),
				xImageDrawPixel = define_c_proc(ray,"+ImageDrawPixel",{C_POINTER,C_INT,C_INT,C_UINT}),
				xImageDrawPixelV = define_c_proc(ray,"+ImageDrawPixelV",{C_POINTER,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawLine = define_c_proc(ray,"+ImageDrawLine",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xImageDrawLineV = define_c_proc(ray,"+ImageDrawLineV",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawCircle = define_c_proc(ray,"+ImageDrawCircle",{C_POINTER,C_INT,C_INT,C_INT,C_UINT}),
				xImageDrawCircleV = define_c_proc(ray,"+ImageDrawCircleV",{C_POINTER,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xImageDrawRectangle = define_c_proc(ray,"+ImageDrawRectangle",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xImageDrawRectangleV = define_c_proc(ray,"+ImageDrawRectangleV",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawRectangleRec = define_c_proc(ray,"+ImageDrawRectangleRec",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawRectangleLines = define_c_proc(ray,"+ImageDrawRectangleLines",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xImageDraw = define_c_proc(ray,"+ImageDraw",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawText = define_c_proc(ray,"+ImageDrawText",{C_POINTER,C_POINTER,C_INT,C_INT,C_INT,C_UINT}),
				xImageDrawTextEx = define_c_proc(ray,"+ImageDrawTextEx",{C_POINTER,C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure ImageClearBackground(atom dst,atom col)

 c_proc(xImageClearBackground,{dst,col})
	
end procedure

public procedure ImageDrawPixel(atom dst,atom x,atom y,atom col)

 c_proc(xImageDrawPixel,{dst,x,y,col})
	
end procedure

public procedure ImageDrawPixelV(atom dst,atom x,atom y,atom col)

 c_proc(xImageDrawPixelV,{dst,x,y,col})
	
end procedure

public procedure ImageDrawLine(atom dst,atom x,atom y,atom ex,atom ey,atom col)

 c_proc(xImageDrawLine,{dst,x,y,ex,ey,col})
	
end procedure

public procedure ImageDrawLineV(atom dst,atom x,atom y,atom ex,atom ey,atom col)

 c_proc(xImageDrawLineV,{dst,x,y,ex,ey,col})
	
end procedure

public procedure ImageDrawCircle(atom dst,atom x,atom y,atom rad,atom col)

 c_proc(xImageDrawCircle,{dst,x,y,rad,col})
	
end procedure

public procedure ImageDrawCircleV(atom dst,atom x,atom y,atom rad,atom col)

 c_proc(xImageDrawCircleV,{dst,x,y,rad,col})
	
end procedure

public procedure ImageDrawRectangle(atom dst,atom x,atom y,atom w,atom h,atom col)

 c_proc(xImageDrawRectangle,{dst,x,y,w,h,col})
	
end procedure

public procedure ImageDrawRectangleV(atom dst,atom x,atom y,atom ex,atom ey,atom col)

 c_proc(xImageDrawRectangleV,{dst,x,y,ex,ey,col})
	
end procedure

public procedure ImageDrawRectangleRec(atom dst,atom x,atom y,atom w,atom h,atom col)

 c_proc(xImageDrawRectangleRec,{dst,x,y,w,h,col})
	
end procedure

public procedure ImageDrawRectangleLines(atom dst,atom x,atom y,atom w,atom h,atom thick,atom col)

 c_proc(xImageDrawRectangleLines,{dst,x,y,w,h,thick,col})
	
end procedure

public procedure ImageDraw(atom dst,atom dat,atom w,atom h,atom mip,atom format,atom x,atom y,atom srcw,atom srch,atom x2,atom y2,atom dstw,atom dsth,atom col)

 c_proc(xImageDraw,{dst,dat,w,h,mip,format,x,y,srcw,srch,x2,y2,dstw,dsth,col})
	
end procedure

public procedure ImageDrawText(atom dst,sequence text,atom x,atom y,atom size,atom col)

 sequence str = allocate_string(text,1)
 
 c_proc(xImageDrawText,{dst,str,x,y,size,col})
	
end procedure

public procedure ImageDrawTextEx(atom dst,atom font,sequence text,atom x,atom y,atom size,atom space,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xImageDrawTextEx,{dst,font,str,x,y,size,space,col})
	
end procedure

--Texture Loading Functions

public constant xLoadTexture = define_c_func(ray,"+LoadTexture",{C_POINTER},C_POINTER),
				xLoadTextureFromImage = define_c_func(ray,"+LoadTextureFromImage",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xLoadTextureCubemap = define_c_func(ray,"+LoadTextureCubemap",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xLoadRenderTexture = define_c_func(ray,"+LoadRenderTexture",{C_INT,C_INT},C_POINTER),
				xUnloadTexture = define_c_proc(ray,"+UnloadTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT}),
				xUnloadRenderTexture = define_c_proc(ray,"+UnloadRenderTexture",{C_POINTER}),
				xUpdateTexture = define_c_proc(ray,"+UpdateTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_POINTER}),
				xUpdateTextureRec = define_c_proc(ray,"+UpdateTextureRec",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER})
				
public function LoadTexture(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadTexture,{str})
	
end function

public function LoadTextureFromImage(atom dat,atom w,atom h,atom mip,atom format)

 return c_func(xLoadTextureFromImage,{dat,w,h,mip,format})
	
end function

public function LoadTextureCubemap(atom dat,atom w,atom h,atom mip,atom format,atom lay)

 return c_func(xLoadTextureCubemap,{dat,w,h,mip,format,lay})
	
end function

public function LoadRenderTexture(atom w,atom h)

 return c_func(xLoadRenderTexture,{w,h})
	
end function

public procedure UnloadTexture(atom id,atom w,atom h,atom mip,atom format)

 c_proc(xUnloadTexture,{id,w,h,mip,format})
	
end procedure

public procedure UnloadRenderTexture(atom targ)

 c_proc(xUnloadRenderTexture,{targ})
	
end procedure

public procedure UpdateTexture(atom id,atom w,atom h,atom mip,atom format,atom pix)

 c_proc(xUpdateTexture,{id,w,h,mip,format,pix})
	
end procedure

public procedure UpdateTextureRec(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom rw,atom rh,atom pix)

 c_proc(xUpdateTextureRec,{id,w,h,mip,format,x,y,rw,rh,pix})
	
end procedure

--Texture Config Functions

public constant xGenTextureMipmaps = define_c_proc(ray,"+GenTextureMipmaps",{C_POINTER}),
				xSetTextureFilter = define_c_proc(ray,"+SetTextureFilter",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT}),
				xSetTextureWrap = define_c_proc(ray,"+SetTextureWrap",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT})
				
public procedure GenTextureMipmaps(atom tex)

 c_proc(xGenTextureMipmaps,{tex})
	
end procedure

public procedure SetTextureFilter(atom id,atom w,atom h,atom mip,atom format,atom filt)

 c_proc(xSetTextureFilter,{id,w,h,mip,format,filt})
	
end procedure

public procedure SetTextureWrap(atom id,atom w,atom h,atom mip,atom format,atom wp)

 c_proc(xSetTextureWrap,{id,w,h,mip,format,wp})
	
end procedure

--Texture Drawing Functions

public constant xDrawTexture = define_c_proc(ray,"+DrawTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawTextureV = define_c_proc(ray,"+DrawTextureV",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureEx = define_c_proc(ray,"+DrawTextureEx",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureRec = define_c_proc(ray,"+DrawTextureRec",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureQuad = define_c_proc(ray,"+DrawTextureQuad",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureTiled = define_c_proc(ray,"+DrawTextureTiled",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTexturePro = define_c_proc(ray,"+DrawTexturePro",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureNPatch = define_c_proc(ray,"+DrawTextureNPatch",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTexturePoly = define_c_proc(ray,"+DrawTexturePoly",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_INT,C_UINT})
				
public procedure DrawTexture(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom col)

 c_proc(xDrawTexture,{id,w,h,mip,format,x,y,col})
	
end procedure

public procedure DrawTextureV(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom col)

 c_proc(xDrawTextureV,{id,w,h,mip,format,x,y,col})
	
end procedure

public procedure DrawTextureEx(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom rot,atom scale,atom col)

 c_proc(xDrawTextureEx,{id,w,h,mip,format,x,y,rot,scale,col})
	
end procedure

public procedure DrawTextureRec(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom rw,atom rh,atom x2,atom y2,atom col)

 c_proc(xDrawTextureRec,{id,w,h,mip,format,x,y,rw,rh,x2,y2,col})
	
end procedure

public procedure DrawTextureQuad(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom ox,atom oy,atom x2,atom y2,atom rw,atom rh,atom col)

 c_proc(xDrawTextureQuad,{id,w,h,mip,format,x,y,ox,oy,x2,y2,rw,rh,col})
	
end procedure

public procedure DrawTextureTiled(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom rw,atom rh,atom dx,atom dy,atom dw,atom dh,atom ox,atom oy,atom rot,atom scale,atom col)

 c_proc(xDrawTextureTiled,{id,w,h,mip,format,x,y,rw,rh,dx,dy,dw,dh,ox,oy,rot,scale,col})
	
end procedure

public procedure DrawTexturePro(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom sw,atom sh,atom dx,atom dy,atom dw,atom dh,atom ox,atom oy,atom rot,atom col)

 c_proc(xDrawTexturePro,{id,w,h,mip,format,x,y,sw,sh,dx,dy,dw,dh,ox,oy,rot,col})
	
end procedure

public procedure DrawTextureNPatch(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom w2,atom h2,atom left,atom top,atom right,atom bottom,atom lay,atom dx,atom dy,atom dw,atom dh,atom ox,atom oy,atom rot,atom col)

 c_proc(xDrawTextureNPatch,{id,w,h,mip,format,x,y,w2,h2,left,top,right,bottom,lay,dx,dy,dw,dh,ox,oy,rot,col})
	
end procedure

public procedure DrawTexturePoly(atom id,atom w,atom h,atom mip,atom format,atom x,atom y,atom px,atom py,atom tx,atom ty,atom pt,atom col)

 c_proc(xDrawTexturePoly,{id,w,h,mip,format,x,y,px,py,tx,ty,pt,col})
	
end procedure

--Color/Pixel Functions

public constant xFade = define_c_func(ray,"+Fade",{C_UINT,C_FLOAT},C_UINT),
				xColorToInt = define_c_func(ray,"+ColorToInt",{C_UINT},C_INT),
				xColorNormalize = define_c_func(ray,"+ColorNormalize",{C_UINT},C_FLOAT),
				xColorFromNormalized = define_c_func(ray,"+ColorFromNormalized",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_UINT),
				xColorToHSV = define_c_func(ray,"+ColorToHSV",{C_UINT},C_UINT),
				xColorFromHSV = define_c_func(ray,"+ColorFromHSV",{C_FLOAT,C_FLOAT,C_FLOAT},C_UINT),
				xColorAlpha = define_c_func(ray,"+ColorAlpha",{C_UINT,C_FLOAT},C_UINT),
				xColorAlphaBlend = define_c_func(ray,"+ColorAlphaBlend",{C_UINT,C_UINT,C_UINT},C_UCHAR),
				xGetColor = define_c_func(ray,"+GetColor",{C_UINT},C_UINT),
				xGetPixelColor = define_c_func(ray,"+GetPixelColor",{C_POINTER,C_INT},C_UINT),
				xSetPixelColor = define_c_proc(ray,"+SetPixelColor",{C_POINTER,C_UINT,C_INT}),
				xGetPixelDataSize = define_c_func(ray,"+GetPixelDataSize",{C_INT,C_INT,C_INT},C_INT)
				
public function Fade(atom col,atom al)

 return c_func(xFade,{col,al})
	
end function

public function ColorToInt(atom col)

 return c_func(xColorToInt,{col})
	
end function

public function ColorNormalize(atom col)

 return c_func(xColorNormalize,{col})
	
end function

public function ColorFromNormalized(atom x,atom y,atom z,atom w)

 return c_func(xColorFromNormalized,{x,y,z,w})
	
end function

public function ColorToHSV(atom col)

 return c_func(xColorToHSV,{col})
	
end function

public function ColorFromHSV(atom hue,atom sat,atom val)

 return c_func(xColorFromHSV,{hue,sat,val})
	
end function

public function ColorAlpha(atom col,atom al)

 return c_func(xColorAlpha,{col,al})
	
end function

public function ColorAlphaBlend(atom col,atom col2,atom col3)

 return c_func(xColorAlphaBlend,{col,col2,col3})
	
end function

public function GetColor(atom hex)

 return c_func(xGetColor,{hex})
	
end function

public function GetPixelColor(atom ptr,atom mat)

 return c_func(xGetPixelColor,{ptr,mat})
	
end function

public procedure SetPixelColor(atom ptr,atom col,atom mat)

 c_proc(xSetPixelColor,{ptr,col,mat})
	
end procedure

public function GetPixelDataSize(atom w,atom h,atom mat)

 return c_func(xGetPixelDataSize,{w,h,mat})
	
end function

--Font Loading Functions

public constant xGetFontDefault = define_c_func(ray,"+GetFontDefault",{},C_POINTER),
				xLoadFont = define_c_func(ray,"+LoadFont",{C_POINTER},C_POINTER),
				xLoadFontEx = define_c_func(ray,"+LoadFontEx",{C_POINTER,C_INT,C_POINTER,C_INT},C_POINTER),
				xLoadFontFromImage = define_c_func(ray,"+LoadFontFromImage",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT,C_INT},C_POINTER),
				xLoadFontFromMemory = define_c_func(ray,"+LoadFontFromMemory",{C_POINTER,C_POINTER,C_INT,C_INT,C_POINTER,C_INT},C_POINTER),
				xLoadFontData = define_c_func(ray,"+LoadFontData",{C_POINTER,C_INT,C_INT,C_POINTER,C_INT,C_INT},C_POINTER),
				xGenImageFontAtlas = define_c_func(ray,"+GenImageFontAtlas",{C_POINTER,C_POINTER,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xUnloadFontData = define_c_proc(ray,"+UnloadFontData",{C_POINTER,C_INT}),
				xUnloadFont = define_c_proc(ray,"+UnloadFont",{C_POINTER})
				
public function GetFontDefault()

 return c_func(xGetFontDefault,{})
	
end function

public function LoadFont(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFont,{str})
	
end function

public function LoadFontEx(sequence file,atom size,atom fc,atom cnt)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFontEx,{str,size,fc,cnt})
	
end function

public function LoadFontFromImage(atom dat,atom w,atom h,atom mip,atom format,atom col,atom fc)

 return c_func(xLoadFontFromImage,{dat,w,h,mip,format,col,fc})
	
end function

public function LoadFontFromMemory(sequence file,atom fd,atom ds,atom fs,atom fc,atom gc)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFontFromMemory,{str,fd,ds,fs,fc,gc})
	
end function

public function LoadFontData(atom fd,atom ds,atom fs,atom fc,atom gc,atom xtype)

 return c_func(xLoadFontData,{fd,ds,fs,fc,gc,xtype})
	
end function

public function GenImageFontAtlas(atom ch,atom recs,atom gc,atom fs,atom pad,atom pack)

 return c_func(xGenImageFontAtlas,{ch,recs,gc,fs,pad,pack})
	
end function

public procedure UnloadFontData(atom ch,atom gc)

 c_proc(xUnloadFontData,{ch,gc})
	
end procedure

public procedure UnloadFont(atom font)

 c_proc(xUnloadFont,{font})
	
end procedure

--Text Drawing Functions

public constant xDrawFPS = define_c_proc(ray,"+DrawFPS",{C_INT,C_INT}),
				xDrawText = define_c_proc(ray,"+DrawText",{C_POINTER,C_INT,C_INT,C_INT,C_UINT}),
				xDrawTextEx = define_c_proc(ray,"+DrawTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextPro = define_c_proc(ray,"+DrawTextPro",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextCodepoint = define_c_proc(ray,"+DrawTextCodepoint",{C_POINTER,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawFPS(atom x,atom y)

 c_proc(xDrawFPS,{x,y})
	
end procedure

public procedure DrawText(sequence text,atom x,atom y,atom fs,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawText,{str,x,y,fs,col})
	
end procedure

public procedure DrawTextEx(atom font,sequence text,atom x,atom y,atom fs,atom space,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawTextEx,{font,str,x,y,fs,space,col})
	
end procedure

public procedure DrawTextPro(atom font,sequence text,atom x,atom y,atom ox,atom oy,atom rot,atom fs,atom space,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawTextPro,{font,str,x,y,ox,oy,rot,fs,space,col})
	
end procedure

public procedure DrawTextCodepoint(atom font,atom cp,atom x,atom y,atom fs,atom col)

 c_proc(xDrawTextCodepoint,{font,cp,x,y,fs,col})
	
end procedure

--Text Font Info Functions

public constant xMeasureText = define_c_func(ray,"+MeasureText",{C_POINTER,C_INT},C_INT),
				xMeasureTextEx = define_c_func(ray,"+MeasureTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT},C_FLOAT),
				xGetGlyphIndex = define_c_func(ray,"+GetGlyphIndex",{C_POINTER,C_INT},C_INT),
				xGetGlyphInfo = define_c_func(ray,"+GetGlyphInfo",{C_POINTER,C_INT},C_POINTER),
				xGetGlyphAtlasRec = define_c_func(ray,"+GetGlyphAtlasRec",{C_POINTER,C_INT},C_FLOAT)
				
public function MeasureText(sequence t,atom fs)

 atom str = allocate_string(t,1)
 
 return c_func(xMeasureText,{str,fs})
	
end function

public function MeasureTextEx(atom font,sequence t,atom fs,atom space)

 atom str = allocate_string(t,1)
 
 return c_func(xMeasureTextEx,{font,str,fs,space})
	
end function

public function GetGlyphIndex(atom font,atom cp)

 return c_func(xGetGlyphIndex,{font,cp})
	
end function

public function GetGlyphInfo(atom font,atom cp)

 return c_func(xGetGlyphInfo,{font,cp})
	
end function

public function GetGlyphAtlasRec(atom font,atom cp)

 return c_func(xGetGlyphAtlasRec,{font,cp})
	
end function

--Text Codepoint Functions

public constant xLoadCodepoints = define_c_func(ray,"+LoadCodepoints",{C_POINTER,C_POINTER},C_POINTER),
				xUnloadCodepoints = define_c_proc(ray,"+UnloadCodepoints",{C_POINTER}),
				xGetCodepointCount = define_c_func(ray,"+GetCodepointCount",{C_POINTER},C_INT),
				xGetCodepoint = define_c_func(ray,"+GetCodepoint",{C_POINTER,C_POINTER},C_INT),
				xCodepointToUTF8 = define_c_func(ray,"+CodepointToUTF8",{C_INT,C_POINTER},C_POINTER),
				xTextCodepointsToUTF8 = define_c_func(ray,"+TextCodepointsToUTF8",{C_POINTER,C_INT},C_POINTER)
				
public function LoadCodepoints(sequence t,atom ct)

 atom str = allocate_string(t,1)
 
 return c_func(xLoadCodepoints,{str,ct})
	
end function

public procedure UnloadCodepoints(atom cp)

 c_proc(xUnloadCodepoints,{cp})
	
end procedure

public function GetCodepointCount(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xGetCodepointCount,{str})
	
end function

public function GetCodepoint(sequence t,atom bp)

 atom str = allocate_string(t,1)
 
 return c_func(xGetCodepoint,{str,bp})
	
end function

public function CodepointToUTF8(atom cp,atom bs)

 return c_func(xCodepointToUTF8,{cp,bs})
	
end function

public function TextCodepointsToUTF8(atom cp,atom len)

 return c_func(xTextCodepointsToUTF8,{cp,len})
	
end function

--Text String Functions

public constant xTextCopy = define_c_func(ray,"+TextCopy",{C_POINTER,C_POINTER},C_INT),
				xTextIsEqual = define_c_func(ray,"+TextIsEqual",{C_POINTER,C_POINTER},C_BOOL),
				xTextLength = define_c_func(ray,"+TextLength",{C_POINTER},C_UINT),
				xTextFormat = define_c_func(ray,"+TextFormat",{C_POINTER},C_POINTER),
				xTextSubtext = define_c_func(ray,"+TextSubtext",{C_POINTER,C_INT,C_INT},C_POINTER),
				xTextReplace = define_c_func(ray,"+TextReplace",{C_POINTER,C_POINTER,C_POINTER},C_POINTER),
				xTextInsert = define_c_func(ray,"+TextInsert",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xTextJoin = define_c_func(ray,"+TextJoin",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xTextSplit = define_c_func(ray,"+TextSplit",{C_POINTER,C_CHAR,C_POINTER},C_POINTER),
				xTextAppend = define_c_proc(ray,"+TextAppend",{C_POINTER,C_POINTER,C_POINTER}),
				xTextFindIndex = define_c_func(ray,"+TextFindIndex",{C_POINTER,C_POINTER},C_INT),
				xTextToUpper = define_c_func(ray,"+TextToUpper",{C_POINTER},C_POINTER),
				xTextToLower = define_c_func(ray,"+TextToLower",{C_POINTER},C_POINTER),
				xTextToPascal = define_c_func(ray,"+TextToPascal",{C_POINTER},C_POINTER),
				xTextToInteger = define_c_func(ray,"+TextToInteger",{C_POINTER},C_INT)
				
public function TextCopy(sequence dst,sequence src)

 atom str = allocate_string(dst,1)
 atom str2 = allocate_string(src,1)
 
 return c_func(xTextCopy,{str,str2})
	
end function

public function TextIsEqual(sequence t,sequence t2)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(t2,1)
 
 return c_func(xTextIsEqual,{str,str2})
	
end function

public function TextLength(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xTextLength,{str})
	
end function

public function TextSubtext(sequence t,atom pos,atom len)

 atom str = allocate_string(t,1)
 
 return c_func(xTextSubtext,{str,pos,len})
	
end function

public function TextReplace(sequence t,atom r,sequence b)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(r,1)
 atom str3 = allocate_string(b,1)
 
 return c_func(xTextReplace,{str,str2,str3})
	
end function

public function TextInsert(sequence t,sequence i,atom pos)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(i,1)
 
 return c_func(xTextInsert,{str,str2,pos})
	
end function

public function TextJoin(sequence t,atom ct,sequence d)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(d,1)
 
 return c_func(xTextJoin,{str,ct,str2})
	
end function

public function TextSplit(sequence t,sequence d,atom ct)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(d,1)
 
 return c_func(xTextSplit,{str,str2,ct})
	
end function

public procedure TextAppend(sequence t,sequence a,atom pos)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(a,1)
 
 c_proc(xTextAppend,{str,str2,pos})
	
end procedure

public function TextFindIndex(sequence t,sequence f)

 atom str = allocate_string(t,1)
 atom str2 = allocate_string(f,1)
 
 return c_func(xTextFindIndex,{str,str2})
	
end function

public function TextToUpper(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xTextToUpper,{str})
	
end function

public function TextToLower(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xTextToLower,{str})
	
end function

public function TextToPascal(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xTextToPascal,{str})
	
end function

public function TextToInteger(sequence t)

 atom str = allocate_string(t,1)
 
 return c_func(xTextToInteger,{str})
	
end function

--3D Shape Functions

public constant xDrawLine3D = define_c_proc(ray,"+DrawLine3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawPoint3D = define_c_proc(ray,"+DrawPoint3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCircle3D = define_c_proc(ray,"+DrawCircle3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangle3D = define_c_proc(ray,"+DrawTriangle3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangleStrip3D = define_c_proc(ray,"+DrawTriangleStrip3D",{C_POINTER,C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawCube = define_c_proc(ray,"+DrawCube",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeV = define_c_proc(ray,"+DrawCubeV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeWires = define_c_proc(ray,"+DrawCubeWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeWiresV = define_c_proc(ray,"+DrawCubeWiresV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeTexture = define_c_proc(ray,"+DrawCubeTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeTextureRec = define_c_proc(ray,"+DrawCubeTextureRec",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawSphere = define_c_proc(ray,"+DrawSphere",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawSphereEx = define_c_proc(ray,"+DrawSphereEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_UINT}),
				xDrawSphereWires = define_c_proc(ray,"+DrawSphereWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_UINT}),
				xDrawCylinder = define_c_proc(ray,"+DrawCylinder",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCylinderEx = define_c_proc(ray,"+DrawCylinderEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCylinderWires = define_c_proc(ray,"+DrawCylinderWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCylinderWiresEx = define_c_proc(ray,"+DrawCylinderWiresEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawPlane = define_c_proc(ray,"+DrawPlane",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRay = define_c_proc(ray,"+DrawRay",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawGrid = define_c_proc(ray,"+DrawGrid",{C_INT,C_FLOAT})
				
public procedure DrawLine3D(atom x,atom y,atom z,atom ex,atom ey,atom ez,atom col)

 c_proc(xDrawLine3D,{x,y,z,ex,ey,ez,col})
	
end procedure

public procedure DrawPoint3D(atom x,atom y,atom z,atom col)

 c_proc(xDrawPoint3D,{x,y,z,col})
	
end procedure

public procedure DrawCircle3D(atom x,atom y,atom z,atom rad,atom rx,atom ry,atom rz,atom rotang,atom col)

 c_proc(xDrawCircle3D,{x,y,z,rad,rx,ry,rz,rotang,col})
	
end procedure

public procedure DrawTriangle3D(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3,atom col)

 c_proc(xDrawTriangle3D,{x,y,z,x2,y2,z2,x3,y3,z3,col})
	
end procedure

public procedure DrawTriangleStrip3D(atom x,atom y,atom z,atom pc,atom col)

 c_proc(xDrawTriangleStrip3D,{x,y,z,pc,col})
	
end procedure

public procedure DrawCube(atom x,atom y,atom z,atom w,atom h,atom len,atom col)

 c_proc(xDrawCube,{x,y,z,w,h,len,col})
	
end procedure

public procedure DrawCubeV(atom x,atom y,atom z,atom sx,atom sy,atom sz,atom col)

 c_proc(xDrawCubeV,{x,y,z,sx,sy,sz,col})
	
end procedure

public procedure DrawCubeWires(atom x,atom y,atom z,atom w,atom h,atom len,atom col)

 c_proc(xDrawCubeWires,{x,y,z,w,h,len,col})
	
end procedure

public procedure DrawCubeWiresV(atom x,atom y,atom z,atom sx,atom sy,atom sz,atom col)

 c_proc(xDrawCubeWiresV,{x,y,z,sx,sy,sz,col})
	
end procedure

public procedure DrawCubeTexture(atom id,atom w,atom h,atom mip,atom mat,atom x,atom y,atom z,atom w2,atom h2,atom len,atom col)

 c_proc(xDrawCubeTexture,{id,w,h,mip,mat,x,y,z,w2,h2,len,col})
	
end procedure

public procedure DrawCubeTextureRec(atom id,atom w,atom h,atom mip,atom mat,atom x,atom y,atom rw,atom rh,atom px,atom py,atom pz,atom w2,atom h2,atom len,atom col)

 c_proc(xDrawCubeTextureRec,{id,w,h,mip,mat,x,y,rw,rh,px,py,pz,w2,h2,len,col})
	
end procedure

public procedure DrawSphere(atom x,atom y,atom z,atom rad,atom col)

 c_proc(xDrawSphere,{x,y,z,rad,col})
	
end procedure

public procedure DrawSphereEx(atom x,atom y,atom z,atom rad,atom rings,atom slices,atom col)

 c_proc(xDrawSphereEx,{x,y,z,rad,rings,slices,col})
	
end procedure

public procedure DrawSphereWires(atom x,atom y,atom z,atom rad,atom rings,atom slices,atom col)

 c_proc(xDrawSphereWires,{x,y,z,rad,rings,slices,col})
	
end procedure

public procedure DrawCylinder(atom x,atom y,atom z,atom radtop,atom radbot,atom height,atom slices,atom col)

 c_proc(xDrawCylinder,{x,y,z,radtop,radbot,height,slices,col})
	
end procedure

public procedure DrawCylinderEx(atom x,atom y,atom z,atom ex,atom ey,atom ez,atom sr,atom er,atom sides,atom col)

 c_proc(xDrawCylinderEx,{x,y,z,ex,ey,ez,sr,er,sides,col})
	
end procedure

public procedure DrawCylinderWires(atom x,atom y,atom z,atom rtop,atom rbot,atom height,atom slices,atom col)

 c_proc(xDrawCylinderWires,{x,y,z,rtop,rbot,height,slices,col})
	
end procedure

public procedure DrawCylinderWiresEx(atom x,atom y,atom z,atom ex,atom ey,atom ez,atom sr,atom er,atom sides,atom col)

 c_proc(xDrawCylinderWiresEx,{x,y,z,ex,ey,ez,sr,er,sides,col})
	
end procedure

public procedure DrawPlane(atom x,atom y,atom z,atom sx,atom sy,atom col)

 c_proc(xDrawPlane,{x,y,z,sx,sy,col})
	
end procedure

public procedure DrawRay(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawRay,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawGrid(atom slices,atom space)

 c_proc(xDrawGrid,{slices,space})
	
end procedure

--3D Model Loading Functions

public constant xLoadModel = define_c_func(ray,"+LoadModel",{C_POINTER},C_POINTER),
				xLoadModelFromMesh = define_c_func(ray,"+LoadModelFromMesh",{C_POINTER},C_POINTER),
				xUnloadModel = define_c_proc(ray,"+UnloadModel",{C_POINTER}),
				xUnloadModelKeepMeshes = define_c_proc(ray,"+UnloadModelKeepMeshes",{C_POINTER}),
				xGetModelBoundingBox = define_c_func(ray,"+GetModelBoundingBox",{C_POINTER},C_POINTER)
				
public function LoadModel(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadModel,{str})
	
end function

public function LoadModelFromMesh(atom mesh)

 return c_func(xLoadModelFromMesh,{mesh})
	
end function

public procedure UnloadModel(atom mod)

 c_proc(xUnloadModel,{mod})
	
end procedure

public procedure UnloadModelKeepMeshes(atom mod)

 c_proc(xUnloadModelKeepMeshes,{mod})
	
end procedure

public function GetModelBoundingBox(atom mod)

 return c_func(xGetModelBoundingBox,{mod})
	
end function

--Drawing Model Functions

public constant xDrawModel = define_c_proc(ray,"+DrawModel",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelEx = define_c_proc(ray,"+DrawModelEx",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelWires = define_c_proc(ray,"+DrawModelWires",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelWiresEx = define_c_proc(ray,"+DrawModelWiresEx",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBoundingBox = define_c_proc(ray,"+DrawBoundingBox",{C_POINTER,C_UINT}),
				xDrawBillboard = define_c_proc(ray,"+DrawBillboard",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBillboardRec = define_c_proc(ray,"+DrawBillboardRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBillboardPro = define_c_proc(ray,"+DrawBillboardPro",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawModel(atom mod,atom x,atom y,atom z,atom scale,atom col)

 c_proc(xDrawModel,{mod,x,y,z,scale,col})
	
end procedure

public procedure DrawModelEx(atom mod,atom x,atom y,atom z,atom rx,atom ry,atom rz,atom rotang,atom sx,atom sy,atom sz,atom col)

 c_proc(xDrawModelEx,{mod,x,y,z,rx,ry,rz,rotang,sx,sy,sz,col})
	
end procedure

public procedure DrawModelWires(atom mod,atom x,atom y,atom z,atom scale,atom col)

 c_proc(xDrawModelWires,{mod,x,y,z,scale,col})
	
end procedure

public procedure DrawModelWiresEx(atom mod,atom x,atom y,atom z,atom rx,atom ry,atom rz,atom rotang,atom sx,atom sy,atom sz,atom col)

 c_proc(xDrawModelWiresEx,{mod,x,y,z,rx,ry,rz,rotang,sx,sy,sz,col})
	
end procedure

public procedure DrawBoundingBox(atom bb,atom col)

 c_proc(xDrawBoundingBox,{bb,col})
	
end procedure

public procedure DrawBillboard(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj,atom id,atom w,atom h,atom mip,atom mat,atom px,atom py,atom pz,atom size,atom col)

 c_proc(xDrawBillboard,{x,y,z,tx,ty,tz,ux,uy,uz,fov,proj,id,w,h,mip,mat,px,py,pz,size,col})
	
end procedure

public procedure DrawBillboardRec(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj,atom id,atom w,atom h,atom mip,atom mat,atom rx,atom ry,atom rw,atom rh,atom px,atom py,atom pz,atom sx,atom sy,atom col)

 c_proc(xDrawBillboardRec,{x,y,z,tx,ty,tz,ux,uy,uz,fov,proj,id,w,h,mip,mat,rx,ry,rw,rh,px,py,pz,sx,sy,col})
	
end procedure

public procedure DrawBillboardPro(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,atom proj,atom id,atom w,atom h,atom mip,atom mat,atom rx,atom ry,atom rw,atom rh,atom px,atom py,atom pz,atom sx,atom sy,atom ox,atom oy,atom rot,atom col)

 c_proc(xDrawBillboardPro,{x,y,z,tx,ty,tz,ux,uy,uz,fov,proj,id,w,h,mip,mat,rx,ry,rw,rh,px,py,pz,sx,sy,ox,oy,rot,col})
	
end procedure

--Mesh Management Functions

public constant xUploadMesh = define_c_proc(ray,"+UploadMesh",{C_POINTER,C_BOOL}),
				xUpdateMeshBuffer = define_c_proc(ray,"+UpdateMeshBuffer",{C_POINTER,C_INT,C_POINTER,C_INT,C_INT}),
				xUnloadMesh = define_c_proc(ray,"+UnloadMesh",{C_POINTER}),
				xDrawMesh = define_c_proc(ray,"+DrawMesh",{C_POINTER,C_POINTER,C_FLOAT}),
				xDrawMeshInstanced = define_c_proc(ray,"+DrawMeshInstanced",{C_POINTER,C_POINTER,C_POINTER,C_INT}),
				xExportMesh = define_c_func(ray,"+ExportMesh",{C_POINTER,C_POINTER},C_BOOL),
				xGetMeshBoundingBox = define_c_func(ray,"+GetMeshBoundingBox",{C_POINTER},C_POINTER),
				xGenMeshTangents = define_c_proc(ray,"+GenMeshTangents",{C_POINTER}),
				xGenMeshBinormals = define_c_proc(ray,"+GenMeshBinormals",{C_POINTER})
				
public procedure UploadMesh(atom mesh,atom dyn)

 c_proc(xUploadMesh,{mesh,dyn})
	
end procedure

public procedure UpdateMeshBuffer(atom mesh,atom idx,atom dat,atom size,atom set)

 c_proc(xUpdateMeshBuffer,{mesh,idx,dat,size,set})
	
end procedure

public procedure UnloadMesh(atom mesh)

 c_proc(xUnloadMesh,{mesh})
	
end procedure

public procedure DrawMesh(atom mesh,atom mat,atom trans)

 c_proc(xDrawMesh,{mesh,mat,trans})
	
end procedure

public procedure DrawMeshInstanced(atom mesh,atom mat,atom trans,atom inst)

 c_proc(xDrawMeshInstanced,{mesh,mat,trans,inst})
	
end procedure

public function ExportMesh(atom mesh,sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xExportMesh,{mesh,str})
	
end function

public function GetMeshBoundingBox(atom mesh)

 return c_func(xGetMeshBoundingBox,{mesh})
	
end function

public procedure GenMeshTangents(atom mesh)

 c_proc(xGenMeshTangents,{mesh})
	
end procedure

public procedure GenMeshBinormals(atom mesh)

 c_proc(xGenMeshBinormals,{mesh})
	
end procedure

--Mesh Generation Functions

public constant xGenMeshPoly = define_c_func(ray,"+GenMeshPoly",{C_INT,C_FLOAT},C_POINTER),
				xGenMeshPlane = define_c_func(ray,"+GenMeshPlane",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshCube = define_c_func(ray,"+GenMeshCube",{C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGenMeshSphere = define_c_func(ray,"+GenMeshSphere",{C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshHemiSphere = define_c_func(ray,"+GenMeshHemiSphere",{C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshCylinder = define_c_func(ray,"+GenMeshCylinder",{C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xGenMeshCone = define_c_func(ray,"+GenMeshCone",{C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xGenMeshTorus = define_c_func(ray,"+GenMeshTorus",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshKnot = define_c_func(ray,"+GenMeshKnot",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshHeightmap = define_c_func(ray,"+GenMeshHeightmap",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGenMeshCubicmap = define_c_func(ray,"+GenMeshCubicmap",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)
				
public function GenMeshPoly(atom sides,atom rad)

 return c_func(xGenMeshPoly,{sides,rad})
	
end function

public procedure GenMeshPlane(atom w,atom len,atom x,atom z)

 return c_func(xGenMeshPlane,{w,len,x,z})
	
end procedure

public function GenMeshCube(atom w,atom h,atom len)

 return c_func(xGenMeshCube,{w,h,len})
	
end function

public function GenMeshSphere(atom rad,atom rings,atom slices)

 return c_func(xGenMeshSphere,{rad,rings,slices})
	
end function

public function GenMeshHemiSphere(atom rad,atom rings,atom slices)

 return c_func(xGenMeshHemiSphere,{rad,rings,slices})
	
end function

public function GenMeshCylinder(atom rad,atom h,atom slice)

 return c_func(xGenMeshCylinder,{rad,h,slice})
	
end function

public function GenMeshCone(atom rad,atom h,atom slice)

 return c_func(xGenMeshCone,{rad,h,slice})
	
end function

public function GenMeshTorus(atom rad,atom size,atom seg,atom side)

 return c_func(xGenMeshTorus,{rad,size,seg,side})
	
end function

public function GenMeshKnot(atom rad,atom size,atom seg,atom side)

 return c_func(xGenMeshKnot,{rad,size,seg,side})
	
end function

public function GenMeshHeightmap(atom dat,atom w,atom h,atom mip,atom mat,atom x,atom y,atom z)

 return c_func(xGenMeshHeightmap,{dat,w,h,mip,mat,x,y,z})
	
end function

public function GenMeshCubicmap(atom dat,atom w,atom h,atom mip,atom mat,atom x,atom y,atom z)

 return c_func(xGenMeshCubicmap,{dat,w,h,mip,mat,x,y,z})
	
end function

--Material Loading Functions

public constant xLoadMaterials = define_c_func(ray,"+LoadMaterials",{C_POINTER,C_POINTER},C_POINTER),
				xLoadMaterialDefault = define_c_func(ray,"+LoadMaterialDefault",{},C_POINTER),
				xUnloadMaterial = define_c_proc(ray,"+UnloadMaterial",{C_POINTER}),
				xSetMaterialTexture = define_c_proc(ray,"+SetMaterialTexture",{C_POINTER,C_INT,C_UINT,C_INT,C_INT,C_INT,C_INT}),
				xSetModelMeshMaterial = define_c_proc(ray,"+SetModelMeshMaterial",{C_POINTER,C_INT,C_INT})
				
public function LoadMaterials(sequence file,atom cnt)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMaterials,{str,cnt})
	
end function

public function LoadMaterialDefault()

 return c_func(xLoadMaterialDefault,{})
	
end function

public procedure UnloadMaterial(atom mat)

 c_proc(xUnloadMaterial,{mat})
	
end procedure

public procedure SetMaterialTexture(atom mat,atom mt,atom id,atom w,atom h,atom mip,atom mate)

 c_proc(xSetMaterialTexture,{mat,mt,id,w,h,mip,mate})
	
end procedure

public procedure SetModelMeshMaterial(atom mod,atom id,atom mat)

 c_proc(xSetModelMeshMaterial,{mod,id,mat})
	
end procedure

--Model Animation Loading Functions

public constant xLoadModelAnimations = define_c_func(ray,"+LoadModelAnimations",{C_POINTER,C_POINTER},C_POINTER),
				xUpdateModelAnimation = define_c_proc(ray,"+UpdateModelAnimation",{C_POINTER,C_POINTER,C_INT}),
				xUnloadModelAnimation = define_c_proc(ray,"+UnloadModelAnimation",{C_POINTER}),
				xUnloadModelAnimations = define_c_proc(ray,"+UnloadModelAnimations",{C_POINTER,C_UINT}),
				xIsModelAnimationValid = define_c_func(ray,"+IsModelAnimationValid",{C_POINTER,C_POINTER},C_BOOL)
				
public function LoadModelAnimations(sequence file,atom ac)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadModelAnimations,{str,ac})
	
end function

public procedure UpdateModelAnimation(atom mod,atom ani,atom frame)

 c_proc(xUpdateModelAnimation,{mod,ani,frame})
	
end procedure

public procedure UnloadModelAnimation(atom ani)

 c_proc(xUnloadModelAnimation,{ani})
	
end procedure

public procedure UnloadModelAnimations(atom ani,atom ct)

 c_proc(xUnloadModelAnimations,{ani,ct})
	
end procedure

public function IsModelAnimationValid(atom mod,atom ani)

 return c_func(xIsModelAnimationValid,{mod,ani})
	
end function

--Collision Detection Functions

public constant xCheckCollisionSpheres = define_c_func(ray,"+CheckCollisionSpheres",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionBoxes = define_c_func(ray,"+CheckCollisionBoxes",{C_POINTER,C_POINTER},C_BOOL),
				xCheckCollisionBoxSphere = define_c_func(ray,"+CheckCollisionBoxSphere",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xGetRayCollisionSphere = define_c_func(ray,"+GetRayCollisionSphere",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGetRayCollisionBox = define_c_func(ray,"+GetRayCollisionBox",{C_POINTER,C_POINTER},C_POINTER),
				xGetRayCollisionModel = define_c_func(ray,"+GetRayCollisionModel",{C_POINTER,C_POINTER},C_POINTER),
				xGetRayCollisionMesh = define_c_func(ray,"+GetRayCollisionMesh",{C_POINTER,C_POINTER,C_FLOAT},C_POINTER),
				xGetRayCollisionTriangle = define_c_func(ray,"+GetRayCollisionTriangle",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGetRayCollisionQuad = define_c_func(ray,"+GetRayCollisionQuad",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)
				
public function CheckCollisionSpheres(atom x,atom y,atom z,atom rad,atom x2,atom y2,atom z2,atom rad2)

 return c_func(xCheckCollisionSpheres,{x,y,z,rad,x2,y2,z2,rad2})
	
end function

public function CheckCollisionBoxes(atom bb,atom bb2)

 return c_func(xCheckCollisionBoxes,{bb,bb2})
	
end function

public function CheckCollisionBoxSphere(atom bb,atom x,atom y,atom z,atom rad)

 return c_func(xCheckCollisionBoxSphere,{bb,x,y,z,rad})
	
end function

public function GetRayCollisionSphere(atom ray,atom x,atom y,atom z,atom rad)

 return c_func(xGetRayCollisionSphere,{ray,x,y,z,rad})
	
end function

public function GetRayCollisionBox(atom ray,atom bb)

 return c_func(xGetRayCollisionBox,{ray,bb})
	
end function

public function GetRayCollisionModel(atom ray,atom mod)

 return c_func(xGetRayCollisionModel,{ray,mod})
	
end function

public function GetRayCollisionMesh(atom ray,atom mesh,atom trans)

 return c_func(xGetRayCollisionMesh,{ray,mesh,trans})
	
end function

public function GetRayCollisionTriangle(atom ray,atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3)

 return c_func(xGetRayCollisionTriangle,{ray,x,y,z,x2,y2,z2,x3,y3,z3})
	
end function

public function GetRayCollisionQuad(atom ray,atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3,atom x4,atom y4,atom z4)

 return c_func(xGetRayCollisionQuad,{ray,x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4})
	
end function

--Audio Functions

public constant xInitAudioDevice = define_c_proc(ray,"+InitAudioDevice",{}),
				xCloseAudioDevice = define_c_proc(ray,"+CloseAudioDevice",{}),
				xIsAudioDeviceReady = define_c_func(ray,"+IsAudioDeviceReady",{},C_BOOL),
				xSetMasterVolume = define_c_proc(ray,"+SetMasterVolume",{C_FLOAT})
				
public procedure InitAudioDevice()

 c_proc(xInitAudioDevice,{})
	
end procedure

public procedure CloseAudioDevice()

 c_proc(xCloseAudioDevice,{})
	
end procedure

public function IsAudioDeviceReady()

 return c_func(xIsAudioDeviceReady,{})
	
end function

public procedure SetMasterVolume(atom vol)

 c_proc(xSetMasterVolume,{vol})
	
end procedure

--Wave Loading Functions

public constant xLoadWave = define_c_func(ray,"+LoadWave",{C_POINTER},C_POINTER),
				xLoadWaveFromMemory = define_c_func(ray,"+LoadWaveFromMemory",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xLoadSound = define_c_func(ray,"+LoadSound",{C_POINTER},C_POINTER),
				xLoadSoundFromWave = define_c_func(ray,"+LoadSoundFromWave",{C_POINTER},C_POINTER),
				xUpdateSound = define_c_proc(ray,"+UpdateSound",{C_POINTER,C_POINTER,C_INT}),
				xUnloadWave = define_c_proc(ray,"+UnloadWave",{C_POINTER}),
				xUnloadSound = define_c_proc(ray,"+UnloadSound",{C_POINTER}),
				xExportWave = define_c_func(ray,"+ExportWave",{C_POINTER,C_POINTER},C_BOOL),
				xExportWaveAsCode = define_c_func(ray,"+ExportWaveAsCode",{C_POINTER,C_POINTER},C_BOOL)
				
public function LoadWave(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadWave,{str})
	
end function

public function LoadWaveFromMemory(sequence file,atom dat,atom size)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadWaveFromMemory,{str,dat,size})
	
end function

public function LoadSound(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadSound,{str})
	
end function

public function LoadSoundFromWave(atom wav)

 return c_func(xLoadSoundFromWave,{wav})
	
end function

public procedure UpdateSound(atom snd,atom dat,atom cnt)

 c_proc(xUpdateSound,{snd,dat,cnt})
	
end procedure

public procedure UnloadWave(atom wav)

 c_proc(xUnloadWave,{wav})
	
end procedure

public procedure UnloadSound(atom snd)

 c_proc(xUnloadSound,{snd})
	
end procedure

public function ExportWave(atom wav,sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xExportWave,{wav,str})
	
end function

public function ExportWaveAsCode(atom wav,sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xExportWaveAsCode,{wav,str})
	
end function

--Sound Management Functions

public constant xPlaySound = define_c_proc(ray,"+PlaySound",{C_POINTER}),
				xStopSound = define_c_proc(ray,"+StopSound",{C_POINTER}),
				xPauseSound = define_c_proc(ray,"+PauseSound",{C_POINTER}),
				xResumeSound = define_c_proc(ray,"+ResumeSound",{C_POINTER}),
				xPlaySoundMulti = define_c_proc(ray,"+PlaySoundMulti",{C_POINTER}),
				xStopSoundMulti = define_c_proc(ray,"+StopSoundMulti",{C_POINTER}),
				xGetSoundsPlaying = define_c_func(ray,"+GetSoundsPlaying",{},C_INT),
				xIsSoundPlaying = define_c_func(ray,"+IsSoundPlaying",{C_POINTER},C_BOOL),
				xSetSoundVolume = define_c_proc(ray,"+SetSoundVolume",{C_POINTER,C_FLOAT}),
				xSetSoundPitch = define_c_proc(ray,"+SetSoundPitch",{C_POINTER,C_FLOAT}),
				xWaveFormat = define_c_proc(ray,"+WaveFormat",{C_POINTER,C_INT,C_INT,C_INT}),
				xWaveCopy = define_c_func(ray,"+WaveCopy",{C_POINTER},C_POINTER),
				xWaveCrop = define_c_proc(ray,"+WaveCrop",{C_POINTER,C_INT,C_INT}),
				xLoadWaveSamples = define_c_func(ray,"+LoadWaveSamples",{C_POINTER},C_POINTER),
				xUnloadWaveSamples = define_c_proc(ray,"+UnloadWaveSamples",{C_POINTER})
				
public procedure PlaySound(atom snd)

 c_proc(xPlaySound,{snd})
	
end procedure

public procedure StopSound(atom snd)

 c_proc(xStopSound,{snd})
	
end procedure

public procedure PauseSound(atom snd)

 c_proc(xPauseSound,{snd})
	
end procedure

public procedure ResumeSound(atom snd)

 c_proc(xResumeSound,{snd})
	
end procedure

public procedure PlaySoundMulti(atom snd)

 c_proc(xPlaySoundMulti,{snd})
	
end procedure

public procedure StopSoundMulti(atom snd)

 c_proc(xStopSoundMulti,{snd})
	
end procedure

public function GetSoundsPlaying()

 return c_func(xGetSoundsPlaying,{})
	
end function

public function IsSoundPlaying(atom snd)

 return c_func(xIsSoundPlaying,{snd})
	
end function

public procedure SetSoundVolume(atom snd,atom vol)
 
 c_proc(xSetSoundVolume,{snd,vol})
	
end procedure

public procedure SetSoundPitch(atom snd,atom pit)

 c_proc(xSetSoundPitch,{snd,pit})
	
end procedure

public procedure WaveFormat(atom wav,atom sr,atom ss,atom chan)

 c_proc(xWaveFormat,{wav,sr,ss,chan})
	
end procedure

public function WaveCopy(atom wav)

 return c_func(xWaveCopy,{wav})
	
end function

public procedure WaveCrop(atom wav,atom is,atom fs)

 c_proc(xWaveCrop,{wav,is,fs})
	
end procedure

public function LoadWaveSamples(atom wav)

 return c_func(xLoadWaveSamples,{wav})
	
end function

public procedure UnloadWaveSamples(atom samp)

 c_proc(xUnloadWaveSamples,{samp})
	
end procedure

--Music Management Functions

public constant xLoadMusicStream = define_c_func(ray,"+LoadMusicStream",{C_POINTER},C_POINTER),
				xLoadMusicStreamFromMemory = define_c_func(ray,"+LoadMusicStreamFromMemory",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xUnloadMusicStream = define_c_proc(ray,"+UnloadMusicStream",{C_POINTER}),
				xPlayMusicStream = define_c_proc(ray,"+PlayMusicStream",{C_POINTER}),
				xIsMusicStreamPlaying = define_c_func(ray,"+IsMusicStreamPlaying",{C_POINTER},C_BOOL),
				xUpdateMusicStream = define_c_proc(ray,"+UpdateMusicStream",{C_POINTER}),
				xStopMusicStream = define_c_proc(ray,"+StopMusicStream",{C_POINTER}),
				xPauseMusicStream = define_c_proc(ray,"+PauseMusicStream",{C_POINTER}),
				xResumeMusicStream = define_c_proc(ray,"+ResumeMusicStream",{C_POINTER}),
				xSeekMusicStream = define_c_proc(ray,"+SeekMusicStream",{C_POINTER,C_FLOAT}),
				xSetMusicVolume = define_c_proc(ray,"+SetMusicVolume",{C_POINTER,C_FLOAT}),
				xSetMusicPitch = define_c_proc(ray,"+SetMusicPitch",{C_POINTER,C_FLOAT}),
				xGetMusicTimeLength = define_c_func(ray,"+GetMusicTimeLength",{C_POINTER},C_FLOAT),
				xGetMusicTimePlayed = define_c_func(ray,"+GetMusicTimePlayed",{C_POINTER},C_FLOAT)
				
public function LoadMusicStream(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMusicStream,{str})
	
end function

public function LoadMusicStreamFromMemory(sequence file,atom dat,atom size)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMusicStreamFromMemory,{str,dat,size})
	
end function

public procedure UnloadMusicStream(atom mus)
 
 c_proc(xUnloadMusicStream,{mus})
	
end procedure

public procedure PlayMusicStream(atom mus)

 c_proc(xPlayMusicStream,{mus})
	
end procedure

public procedure IsMusicStreamPlaying(atom mus)

 return c_func(xIsMusicStreamPlaying,{mus})
	
end procedure

public procedure UpdateMusicStream(atom mus)

 c_proc(xUpdateMusicStream,{mus})
	
end procedure

public procedure PauseMusicStream(atom mus)

 c_proc(xPauseMusicStream,{mus})
	
end procedure

public procedure ResumeMusicStream(atom mus)

 c_proc(xResumeMusicStream,{mus})
	
end procedure

public procedure SeekMusicStream(atom mus,atom pos)

 c_proc(xSeekMusicStream,{mus,pos})
	
end procedure

public procedure SetMusicVolume(atom mus,atom vol)

 c_proc(xSetMusicVolume,{mus,vol})
	
end procedure

public procedure SetMusicPitch(atom mus,atom pit)

 c_proc(xSetMusicPitch,{mus,pit})
	
end procedure

public function GetMusicTimeLength(atom mus)

 return c_func(xGetMusicTimeLength,{mus})
	
end function

public function GetMusicTimePlayed(atom mus)

 return c_func(xGetMusicTimePlayed,{mus})
	
end function

--AudioStream Functions

public constant xLoadAudioStream = define_c_func(ray,"+LoadAudioStream",{C_UINT,C_UINT,C_UINT},C_POINTER),
				xUnloadAudioStream = define_c_proc(ray,"+UnloadAudioStream",{C_POINTER}),
				xUpdateAudioStream = define_c_proc(ray,"+UpdateAudioStream",{C_POINTER,C_POINTER,C_INT}),
				xIsAudioStreamProcessed = define_c_func(ray,"+IsAudioStreamProcessed",{C_POINTER},C_BOOL),
				xPlayAudioStream = define_c_proc(ray,"+PlayAudioStream",{C_POINTER}),
				xPauseAudioStream = define_c_proc(ray,"+PauseAudioStream",{C_POINTER}),
				xResumeAudioStream = define_c_proc(ray,"+ResumeAudioStream",{C_POINTER}),
				xIsAudioStreamPlaying = define_c_func(ray,"+IsAudioStreamPlaying",{C_POINTER},C_BOOL),
				xStopAudioStream = define_c_proc(ray,"+StopAudioStream",{C_POINTER}),
				xSetAudioStreamVolume = define_c_proc(ray,"+SetAudioStreamVolume",{C_POINTER,C_FLOAT}),
				xSetAudioStreamPitch = define_c_proc(ray,"+SetAudioStreamPitch",{C_POINTER,C_FLOAT}),
				xSetAudioStreamBufferSizeDefault = define_c_proc(ray,"+SetAudioStreamBufferSizeDefault",{C_INT})
				
public function LoadAudioStream(atom sr,atom ss,atom chan)

 return c_func(xLoadAudioStream,{sr,ss,chan})
	
end function

public procedure UnloadAudioStream(atom s)

 c_proc(xUnloadAudioStream,{s})
	
end procedure

public procedure UpdateAudioStream(atom s,atom dat,atom fc)

 c_proc(xUpdateAudioStream,{s,dat,fc})
	
end procedure

public function IsAudioStreamProcessed(atom s)

 return c_func(xIsAudioStreamProcessed,{s})
	
end function

public procedure PlayAudioStream(atom s)

 c_proc(xPlayAudioStream,{s})
	
end procedure

public procedure PauseAudioStream(atom s)

 c_proc(xPauseAudioStream,{s})
	
end procedure

public procedure ResumeAudioStream(atom s)

 c_proc(xResumeAudioStream,{s})
	
end procedure

public function IsAudioStreamPlaying(atom s)

 return c_func(xIsAudioStreamPlaying,{s})
	
end function

public procedure StopAudioStream(atom s)

 c_proc(xStopAudioStream,{s})
	
end procedure

public procedure SetAudioStreamVolume(atom s,atom vol)

 c_proc(xSetAudioStreamVolume,{s,vol})
	
end procedure

public procedure SetAudioStreamPitch(atom s,atom pit)

 c_proc(xSetAudioStreamPitch,{s,pit})
	
end procedure

public procedure SetAudioStreamBufferSizeDefault(atom size)

 c_proc(xSetAudioStreamBufferSizeDefault,{size})
	
end procedure
3638.17